 
diff -ur hdf5-1.10.0-patch1/hl/COPYING hdf5/hl/COPYING
--- hdf5-1.10.0-patch1/hl/COPYING	2016-03-28 17:26:50.000000000 +0100
+++ hdf5/hl/COPYING	2021-01-25 11:09:43.000000000 +0000
@@ -1,16 +1,16 @@
-
-  Copyright by  The HDF Group and 
-                The Board of Trustees of the University of Illinois. 
-  All rights reserved. 
-
-  The files and subdirectories in this directory are part of HDF5.  
-  The full HDF5 copyright notice, including terms governing use, 
-  modification, and redistribution, is contained in the files COPYING 
-  and Copyright.html.  COPYING can be found at the root of the source 
-  code distribution tree; Copyright.html can be found at the root 
-  level of an installed copy of the electronic HDF5 document set and 
-  is linked from the top-level documents page.  It can also be found 
-  at http://www.hdfgroup.org/HDF5/doc/Copyright.html.  If you do not 
-  have access to either file, you may request a copy from 
-  help@hdfgroup.org. 
-
+
+  Copyright by  The HDF Group and 
+                The Board of Trustees of the University of Illinois. 
+  All rights reserved. 
+
+  The files and subdirectories in this directory are part of HDF5.  
+  The full HDF5 copyright notice, including terms governing use, 
+  modification, and redistribution, is contained in the files COPYING 
+  and Copyright.html.  COPYING can be found at the root of the source 
+  code distribution tree; Copyright.html can be found at the root 
+  level of an installed copy of the electronic HDF5 document set and 
+  is linked from the top-level documents page.  It can also be found 
+  at http://www.hdfgroup.org/HDF5/doc/Copyright.html.  If you do not 
+  have access to either file, you may request a copy from 
+  help@hdfgroup.org. 
+
Only in hdf5-1.10.0-patch1/hl: Makefile.am
Only in hdf5-1.10.0-patch1/hl: Makefile.in
Only in hdf5-1.10.0-patch1/hl: c++
Only in hdf5-1.10.0-patch1/hl: examples
Only in hdf5-1.10.0-patch1/hl: fortran
diff -ur hdf5-1.10.0-patch1/hl/src/H5LTparse.c hdf5/hl/src/H5LTparse.c
--- hdf5-1.10.0-patch1/hl/src/H5LTparse.c	2016-03-28 17:26:48.000000000 +0100
+++ hdf5/hl/src/H5LTparse.c	2021-01-25 11:09:43.000000000 +0000
@@ -1,2287 +1,1149 @@
-#if __GNUC__ >= 4 && __GNUC_MINOR__ >=2                           
-#pragma GCC diagnostic ignored "-Wconversion"                     
-#pragma GCC diagnostic ignored "-Wimplicit-function-declaration"  
-#pragma GCC diagnostic ignored "-Wlarger-than="                   
-#pragma GCC diagnostic ignored "-Wmissing-prototypes"             
-#pragma GCC diagnostic ignored "-Wnested-externs"                 
-#pragma GCC diagnostic ignored "-Wold-style-definition"           
-#pragma GCC diagnostic ignored "-Wredundant-decls"                
-#pragma GCC diagnostic ignored "-Wsign-compare"                   
-#pragma GCC diagnostic ignored "-Wsign-conversion"                
-#pragma GCC diagnostic ignored "-Wstrict-overflow"                
-#pragma GCC diagnostic ignored "-Wstrict-prototypes"              
-#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"         
-#pragma GCC diagnostic ignored "-Wswitch-default"                 
-#pragma GCC diagnostic ignored "-Wunused-function"                
-#pragma GCC diagnostic ignored "-Wunused-macros"                  
-#pragma GCC diagnostic ignored "-Wunused-parameter"               
-#elif defined __SUNPRO_CC                                         
-#pragma disable_warn                                              
-#elif defined _MSC_VER                                            
-#pragma warning(push, 1)                                          
-#endif                                                            
-/* A Bison parser, made by GNU Bison 3.0.2.  */
-
-/* Bison implementation for Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "3.0.2"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
-
-/* Substitute the variable and function names.  */
-#define yyparse         H5LTyyparse
-#define yylex           H5LTyylex
-#define yyerror         H5LTyyerror
-#define yydebug         H5LTyydebug
-#define yynerrs         H5LTyynerrs
-
-#define yylval          H5LTyylval
-#define yychar          H5LTyychar
-
-/* Copy the first part of user declarations.  */
-#line 22 "hl/src/H5LTparse.y" /* yacc.c:339  */
-
-#include <stdio.h>
-#include <string.h>
-#include <hdf5.h>
-
-extern int yylex();
-extern int yyerror(const char *);
-
-#define STACK_SIZE      16
-
-/*structure for compound type information*/
-struct cmpd_info {
-    hid_t       id;             /*type ID*/
-    hbool_t     is_field;       /*flag to lexer for compound member*/
-    hbool_t     first_memb;     /*flag for first compound member*/
-};
-
-/*stack for nested compound type*/
-struct cmpd_info cmpd_stack[STACK_SIZE] = {
-    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
-    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
-    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
-    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1} };
-
-int csindex = -1;                /*pointer to the top of compound stack*/
-
-/*structure for array type information*/
-struct arr_info {
-    hsize_t             dims[H5S_MAX_RANK];     /*size of each dimension, limited to 32 dimensions*/
-    unsigned            ndims;                  /*number of dimensions*/
-    hbool_t             is_dim;                 /*flag to lexer for dimension*/
-};
-/*stack for nested array type*/
-struct arr_info arr_stack[STACK_SIZE];
-int asindex = -1;               /*pointer to the top of array stack*/ 
-
-hbool_t     is_str_size = 0;        /*flag to lexer for string size*/
-hbool_t     is_str_pad = 0;         /*flag to lexer for string padding*/
-H5T_str_t   str_pad;                /*variable for string padding*/
-H5T_cset_t  str_cset;               /*variable for string character set*/
-hbool_t     is_variable = 0;        /*variable for variable-length string*/
-size_t      str_size;               /*variable for string size*/
-   
-hid_t       enum_id;                /*type ID*/
-hbool_t     is_enum = 0;            /*flag to lexer for enum type*/
-hbool_t     is_enum_memb = 0;       /*flag to lexer for enum member*/
-char*       enum_memb_symbol;       /*enum member symbol string*/
-
-hbool_t is_opq_size = 0;            /*flag to lexer for opaque type size*/
-hbool_t is_opq_tag = 0;             /*flag to lexer for opaque type tag*/
-
-
-#line 127 "hl/src/H5LTparse.c" /* yacc.c:339  */
-
-# ifndef YY_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULLPTR nullptr
-#  else
-#   define YY_NULLPTR 0
-#  endif
-# endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* In a future release of Bison, this section will be replaced
-   by #include "H5LTparse.h".  */
-#ifndef YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED
-# define YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int H5LTyydebug;
-#endif
-
-/* Token type.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    H5T_STD_I8BE_TOKEN = 258,
-    H5T_STD_I8LE_TOKEN = 259,
-    H5T_STD_I16BE_TOKEN = 260,
-    H5T_STD_I16LE_TOKEN = 261,
-    H5T_STD_I32BE_TOKEN = 262,
-    H5T_STD_I32LE_TOKEN = 263,
-    H5T_STD_I64BE_TOKEN = 264,
-    H5T_STD_I64LE_TOKEN = 265,
-    H5T_STD_U8BE_TOKEN = 266,
-    H5T_STD_U8LE_TOKEN = 267,
-    H5T_STD_U16BE_TOKEN = 268,
-    H5T_STD_U16LE_TOKEN = 269,
-    H5T_STD_U32BE_TOKEN = 270,
-    H5T_STD_U32LE_TOKEN = 271,
-    H5T_STD_U64BE_TOKEN = 272,
-    H5T_STD_U64LE_TOKEN = 273,
-    H5T_NATIVE_CHAR_TOKEN = 274,
-    H5T_NATIVE_SCHAR_TOKEN = 275,
-    H5T_NATIVE_UCHAR_TOKEN = 276,
-    H5T_NATIVE_SHORT_TOKEN = 277,
-    H5T_NATIVE_USHORT_TOKEN = 278,
-    H5T_NATIVE_INT_TOKEN = 279,
-    H5T_NATIVE_UINT_TOKEN = 280,
-    H5T_NATIVE_LONG_TOKEN = 281,
-    H5T_NATIVE_ULONG_TOKEN = 282,
-    H5T_NATIVE_LLONG_TOKEN = 283,
-    H5T_NATIVE_ULLONG_TOKEN = 284,
-    H5T_IEEE_F32BE_TOKEN = 285,
-    H5T_IEEE_F32LE_TOKEN = 286,
-    H5T_IEEE_F64BE_TOKEN = 287,
-    H5T_IEEE_F64LE_TOKEN = 288,
-    H5T_NATIVE_FLOAT_TOKEN = 289,
-    H5T_NATIVE_DOUBLE_TOKEN = 290,
-    H5T_NATIVE_LDOUBLE_TOKEN = 291,
-    H5T_STRING_TOKEN = 292,
-    STRSIZE_TOKEN = 293,
-    STRPAD_TOKEN = 294,
-    CSET_TOKEN = 295,
-    CTYPE_TOKEN = 296,
-    H5T_VARIABLE_TOKEN = 297,
-    H5T_STR_NULLTERM_TOKEN = 298,
-    H5T_STR_NULLPAD_TOKEN = 299,
-    H5T_STR_SPACEPAD_TOKEN = 300,
-    H5T_CSET_ASCII_TOKEN = 301,
-    H5T_CSET_UTF8_TOKEN = 302,
-    H5T_C_S1_TOKEN = 303,
-    H5T_FORTRAN_S1_TOKEN = 304,
-    H5T_OPAQUE_TOKEN = 305,
-    OPQ_SIZE_TOKEN = 306,
-    OPQ_TAG_TOKEN = 307,
-    H5T_COMPOUND_TOKEN = 308,
-    H5T_ENUM_TOKEN = 309,
-    H5T_ARRAY_TOKEN = 310,
-    H5T_VLEN_TOKEN = 311,
-    STRING = 312,
-    NUMBER = 313
-  };
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE YYSTYPE;
-union YYSTYPE
-{
-#line 74 "hl/src/H5LTparse.y" /* yacc.c:355  */
-
-    int     ival;         /*for integer token*/
-    char    *sval;        /*for name string*/
-    hid_t   hid;          /*for hid_t token*/
-
-#line 232 "hl/src/H5LTparse.c" /* yacc.c:355  */
-};
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-
-extern YYSTYPE H5LTyylval;
-
-hid_t H5LTyyparse (void);
-
-#endif /* !YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED  */
-
-/* Copy the second part of user declarations.  */
-
-#line 247 "hl/src/H5LTparse.c" /* yacc.c:358  */
-
-#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#else
-typedef signed char yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short int yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short int yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned int
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
-
-#ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(Msgid) Msgid
-# endif
-#endif
-
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
-
-#ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
-#endif
-
-#ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
-# else
-#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
-# endif
-#endif
-
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
-#else
-# define YYUSE(E) /* empty */
-#endif
-
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
-/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
-    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
-    _Pragma ("GCC diagnostic pop")
-#else
-# define YY_INITIAL_VALUE(Value) Value
-#endif
-#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END
-#endif
-#ifndef YY_INITIAL_VALUE
-# define YY_INITIAL_VALUE(Value) /* Nothing. */
-#endif
-
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's 'empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
-       && ! ((defined YYMALLOC || defined malloc) \
-             && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-};
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
-      + YYSTACK_GAP_MAXIMUM)
-
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
-    do                                                                  \
-      {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
-        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
-        Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
-      }                                                                 \
-    while (0)
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
-/* Copy COUNT objects from SRC to DST.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
-#  else
-#   define YYCOPY(Dst, Src, Count)              \
-      do                                        \
-        {                                       \
-          YYSIZE_T yyi;                         \
-          for (yyi = 0; yyi < (Count); yyi++)   \
-            (Dst)[yyi] = (Src)[yyi];            \
-        }                                       \
-      while (0)
-#  endif
-# endif
-#endif /* !YYCOPY_NEEDED */
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  58
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   203
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  66
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  46
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  95
-/* YYNSTATES -- Number of states.  */
-#define YYNSTATES  143
-
-/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
-   by yylex, with out-of-bounds checking.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   313
-
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, without out-of-bounds checking.  */
-static const yytype_uint8 yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    63,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    64,    65,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    61,     2,    62,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    59,     2,    60,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
-      55,    56,    57,    58
-};
-
-#if YYDEBUG
-  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
-{
-       0,   107,   107,   108,   110,   111,   112,   113,   115,   116,
-     117,   118,   119,   122,   123,   124,   125,   126,   127,   128,
-     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
-     139,   140,   141,   142,   143,   144,   145,   146,   147,   148,
-     151,   152,   153,   154,   155,   156,   157,   161,   160,   169,
-     170,   172,   172,   209,   217,   218,   221,   223,   223,   232,
-     233,   235,   236,   235,   243,   246,   252,   253,   258,   259,
-     250,   267,   269,   273,   274,   282,   291,   298,   271,   322,
-     323,   325,   326,   327,   329,   330,   332,   333,   337,   336,
-     341,   342,   344,   344,   398,   400
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || 0
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "H5T_STD_I8BE_TOKEN",
-  "H5T_STD_I8LE_TOKEN", "H5T_STD_I16BE_TOKEN", "H5T_STD_I16LE_TOKEN",
-  "H5T_STD_I32BE_TOKEN", "H5T_STD_I32LE_TOKEN", "H5T_STD_I64BE_TOKEN",
-  "H5T_STD_I64LE_TOKEN", "H5T_STD_U8BE_TOKEN", "H5T_STD_U8LE_TOKEN",
-  "H5T_STD_U16BE_TOKEN", "H5T_STD_U16LE_TOKEN", "H5T_STD_U32BE_TOKEN",
-  "H5T_STD_U32LE_TOKEN", "H5T_STD_U64BE_TOKEN", "H5T_STD_U64LE_TOKEN",
-  "H5T_NATIVE_CHAR_TOKEN", "H5T_NATIVE_SCHAR_TOKEN",
-  "H5T_NATIVE_UCHAR_TOKEN", "H5T_NATIVE_SHORT_TOKEN",
-  "H5T_NATIVE_USHORT_TOKEN", "H5T_NATIVE_INT_TOKEN",
-  "H5T_NATIVE_UINT_TOKEN", "H5T_NATIVE_LONG_TOKEN",
-  "H5T_NATIVE_ULONG_TOKEN", "H5T_NATIVE_LLONG_TOKEN",
-  "H5T_NATIVE_ULLONG_TOKEN", "H5T_IEEE_F32BE_TOKEN",
-  "H5T_IEEE_F32LE_TOKEN", "H5T_IEEE_F64BE_TOKEN", "H5T_IEEE_F64LE_TOKEN",
-  "H5T_NATIVE_FLOAT_TOKEN", "H5T_NATIVE_DOUBLE_TOKEN",
-  "H5T_NATIVE_LDOUBLE_TOKEN", "H5T_STRING_TOKEN", "STRSIZE_TOKEN",
-  "STRPAD_TOKEN", "CSET_TOKEN", "CTYPE_TOKEN", "H5T_VARIABLE_TOKEN",
-  "H5T_STR_NULLTERM_TOKEN", "H5T_STR_NULLPAD_TOKEN",
-  "H5T_STR_SPACEPAD_TOKEN", "H5T_CSET_ASCII_TOKEN", "H5T_CSET_UTF8_TOKEN",
-  "H5T_C_S1_TOKEN", "H5T_FORTRAN_S1_TOKEN", "H5T_OPAQUE_TOKEN",
-  "OPQ_SIZE_TOKEN", "OPQ_TAG_TOKEN", "H5T_COMPOUND_TOKEN",
-  "H5T_ENUM_TOKEN", "H5T_ARRAY_TOKEN", "H5T_VLEN_TOKEN", "STRING",
-  "NUMBER", "'{'", "'}'", "'['", "']'", "'\"'", "':'", "';'", "$accept",
-  "start", "ddl_type", "atomic_type", "integer_type", "fp_type",
-  "compound_type", "$@1", "memb_list", "memb_def", "$@2", "field_name",
-  "field_offset", "offset", "array_type", "$@3", "dim_list", "dim", "$@4",
-  "$@5", "dimsize", "vlen_type", "opaque_type", "$@6", "@7", "$@8", "$@9",
-  "opaque_size", "opaque_tag", "string_type", "$@10", "$@11", "$@12",
-  "$@13", "@14", "strsize", "strpad", "cset", "ctype", "enum_type", "$@15",
-  "enum_list", "enum_def", "$@16", "enum_symbol", "enum_val", YY_NULLPTR
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
-     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
-     305,   306,   307,   308,   309,   310,   311,   312,   313,   123,
-     125,    91,    93,    34,    58,    59
-};
-# endif
-
-#define YYPACT_NINF -25
-
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-25)))
-
-#define YYTABLE_NINF -1
-
-#define yytable_value_is_error(Yytable_value) \
-  0
-
-  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-     STATE-NUM.  */
-static const yytype_int16 yypact[] =
-{
-     114,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -24,   -20,   -25,   -15,   -25,
-     -14,    49,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,    19,    45,    38,   168,    39,   114,   -25,   -25,
-     -25,   -25,    34,   -25,    40,    -4,    43,    56,   -25,    -3,
-     -25,   -25,   -25,    37,   -25,    42,   -25,   -25,   -25,   -25,
-     -25,    44,   -25,   -25,   -25,    50,   -23,    47,   -25,    64,
-      62,    51,   -25,    58,   -25,   -25,   -25,    -2,   -25,   -25,
-      89,   -25,    90,    92,   -25,   -25,   -25,    91,    94,    95,
-     -25,   -25,   -25,    98,   100,    96,   102,   122,   -25,   103,
-     -25,   -25,   -25,   -25,   133,     9,   134,   -25,   -25,   -25,
-     135,   -25,   -25,   105,   160,   -25,    46,   -25,   -25,   137,
-     -25,   143,   -25
-};
-
-  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when YYTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const yytype_uint8 yydefact[] =
-{
-       2,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
-      42,    43,    44,    45,    46,     0,     0,    47,     0,    57,
-       0,     0,     3,     4,     8,     9,     5,     6,     7,    12,
-      10,    11,     0,     0,     0,     0,     0,     0,     1,    73,
-      66,    49,     0,    59,     0,     0,     0,     0,    88,     0,
-      65,    79,    80,     0,    71,     0,    48,    51,    50,    90,
-      61,     0,    60,    74,    67,     0,     0,     0,    58,     0,
-       0,     0,    89,     0,    91,    64,    62,     0,    68,    53,
-       0,    94,     0,     0,    81,    82,    83,     0,     0,    54,
-      92,    63,    75,     0,     0,     0,     0,     0,    72,     0,
-      56,    55,    52,    95,     0,     0,     0,    93,    84,    85,
-       0,    69,    76,     0,     0,    70,     0,    86,    87,     0,
-      77,     0,    78
-};
-
-  /* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
-{
-     -25,   -25,   -21,   -25,   108,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,   -25,
-     -25,   -25,   -25,   -25,   -25,   -25
-};
-
-  /* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int16 yydefgoto[] =
-{
-      -1,    41,    42,    43,    44,    45,    46,    54,    67,    78,
-      85,   100,   115,   121,    47,    56,    69,    82,    87,   103,
-      96,    48,    49,    66,    90,   108,   133,    75,   119,    50,
-      65,    89,   117,   134,   141,    73,   107,   130,   139,    51,
-      79,    86,    94,   116,   102,   124
-};
-
-  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If YYTABLE_NINF, syntax error.  */
-static const yytype_uint8 yytable[] =
-{
-       1,     2,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    35,    52,    64,    92,    71,    53,
-      93,   104,   105,   106,    55,    57,    77,    36,    81,    58,
-      37,    38,    39,    40,    72,   128,   129,    59,    80,     1,
-       2,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,   137,   138,    60,    61,    63,    68,
-      70,    74,    83,    97,    88,    95,    36,    84,    99,    37,
-      38,    39,    40,    91,    98,   101,    76,     1,     2,     3,
-       4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
-      34,    35,   109,   110,   111,   118,   112,   113,   120,   114,
-     123,   122,   125,    62,    36,   135,   126,    37,    38,    39,
-      40,     1,     2,     3,     4,     5,     6,     7,     8,     9,
-      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
-      20,    21,    22,    23,    24,    25,    26,    27,   127,   131,
-     132,   136,   140,   142
-};
-
-static const yytype_uint8 yycheck[] =
-{
-       3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
-      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    35,    36,    37,    59,    57,    60,    42,    59,
-      63,    43,    44,    45,    59,    59,    67,    50,    69,     0,
-      53,    54,    55,    56,    58,    46,    47,    38,    61,     3,
-       4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
-      34,    35,    36,    37,    48,    49,    51,    59,    59,    65,
-      60,    58,    65,    39,    60,    58,    50,    65,    57,    53,
-      54,    55,    56,    63,    52,    57,    60,     3,     4,     5,
-       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    63,    63,    62,    57,    65,    63,    58,    64,
-      58,    65,    40,    55,    50,    60,    63,    53,    54,    55,
-      56,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    65,    65,
-      65,    41,    65,    60
-};
-
-  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
-{
-       0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,    37,    50,    53,    54,    55,
-      56,    67,    68,    69,    70,    71,    72,    80,    87,    88,
-      95,   105,    59,    59,    73,    59,    81,    59,     0,    38,
-      51,    59,    70,    59,    68,    96,    89,    74,    65,    82,
-      60,    42,    58,   101,    58,    93,    60,    68,    75,   106,
-      61,    68,    83,    65,    65,    76,   107,    84,    60,    97,
-      90,    63,    60,    63,   108,    58,    86,    39,    52,    57,
-      77,    57,   110,    85,    43,    44,    45,   102,    91,    63,
-      63,    62,    65,    63,    64,    78,   109,    98,    57,    94,
-      58,    79,    65,    58,   111,    40,    63,    65,    46,    47,
-     103,    65,    65,    92,    99,    60,    41,    48,    49,   104,
-      65,   100,    60
-};
-
-  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    66,    67,    67,    68,    68,    68,    68,    69,    69,
-      69,    69,    69,    70,    70,    70,    70,    70,    70,    70,
-      70,    70,    70,    70,    70,    70,    70,    70,    70,    70,
-      70,    70,    70,    70,    70,    70,    70,    70,    70,    70,
-      71,    71,    71,    71,    71,    71,    71,    73,    72,    74,
-      74,    76,    75,    77,    78,    78,    79,    81,    80,    82,
-      82,    84,    85,    83,    86,    87,    89,    90,    91,    92,
-      88,    93,    94,    96,    97,    98,    99,   100,    95,   101,
-     101,   102,   102,   102,   103,   103,   104,   104,   106,   105,
-     107,   107,   109,   108,   110,   111
-};
-
-  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
-{
-       0,     2,     0,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     0,     5,     0,
-       2,     0,     7,     1,     0,     2,     1,     0,     6,     0,
-       2,     0,     0,     5,     1,     4,     0,     0,     0,     0,
-      15,     1,     1,     0,     0,     0,     0,     0,    20,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     0,     7,
-       0,     2,     0,     6,     1,     1
-};
-
-
-#define yyerrok         (yyerrstatus = 0)
-#define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
-
-#define YYACCEPT        goto yyacceptlab
-#define YYABORT         goto yyabortlab
-#define YYERROR         goto yyerrorlab
-
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;                                                  \
-    }                                                           \
-while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
-
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)                        \
-do {                                            \
-  if (yydebug)                                  \
-    YYFPRINTF Args;                             \
-} while (0)
-
-/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
-
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
-do {                                                                      \
-  if (yydebug)                                                            \
-    {                                                                     \
-      YYFPRINTF (stderr, "%s ", Title);                                   \
-      yy_symbol_print (stderr,                                            \
-                  Type, Value); \
-      YYFPRINTF (stderr, "\n");                                           \
-    }                                                                     \
-} while (0)
-
-
-/*----------------------------------------.
-| Print this symbol's value on YYOUTPUT.  |
-`----------------------------------------*/
-
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-{
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  YYUSE (yytype);
-}
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-{
-  YYFPRINTF (yyoutput, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
-
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
-}
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)                            \
-do {                                                            \
-  if (yydebug)                                                  \
-    yy_stack_print ((Bottom), (Top));                           \
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
-{
-  unsigned long int yylno = yyrline[yyrule];
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-             yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &(yyvsp[(yyi + 1) - (yynrhs)])
-                                              );
-      YYFPRINTF (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)          \
-do {                                    \
-  if (yydebug)                          \
-    yy_reduce_print (yyssp, yyvsp, Rule); \
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-yystrlen (const char *yystr)
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            /* Fall through.  */
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  yysize = yysize1;
-                }
-              }
-        }
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-      return 2;
-    yysize = yysize1;
-  }
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-{
-  YYUSE (yyvaluep);
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  YYUSE (yytype);
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-}
-
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-hid_t
-yyparse (void)
-{
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
-
-       Refer to the stacks through separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYSIZE_T yystacksize;
-
-  int yyn;
-  int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
-
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
-
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-        /* Give user a chance to reallocate the stack.  Use copies of
-           these so that the &'s don't force the real ones into
-           memory.  */
-        YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
-
-        /* Each stack pointer address is followed by the size of the
-           data in use in that stack, in bytes.  This used to be a
-           conditional around just the two extra args, but that might
-           be undefined if yyoverflow is a macro.  */
-        yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
-                    &yystacksize);
-
-        yyss = yyss1;
-        yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-        yystacksize = YYMAXDEPTH;
-
-      {
-        yytype_int16 *yyss1 = yyss;
-        union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-        if (! yyptr)
-          goto yyexhaustedlab;
-        YYSTACK_RELOCATE (yyss_alloc, yyss);
-        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
-#  undef YYSTACK_RELOCATE
-        if (yyss1 != yyssa)
-          YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-        YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-  /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-  yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = yylex ();
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the lookahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
-  yystate = yyn;
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     '$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 2:
-#line 107 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { memset(arr_stack, 0, STACK_SIZE*sizeof(struct arr_info)); /*initialize here?*/ }
-#line 1468 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 3:
-#line 108 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { return (yyval.hid);}
-#line 1474 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 13:
-#line 122 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I8BE); }
-#line 1480 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 14:
-#line 123 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I8LE); }
-#line 1486 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 15:
-#line 124 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I16BE); }
-#line 1492 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 16:
-#line 125 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I16LE); }
-#line 1498 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 17:
-#line 126 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I32BE); }
-#line 1504 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 18:
-#line 127 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I32LE); }
-#line 1510 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 19:
-#line 128 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I64BE); }
-#line 1516 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 20:
-#line 129 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_I64LE); }
-#line 1522 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 21:
-#line 130 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U8BE); }
-#line 1528 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 22:
-#line 131 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U8LE); }
-#line 1534 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 23:
-#line 132 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U16BE); }
-#line 1540 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 24:
-#line 133 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U16LE); }
-#line 1546 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 25:
-#line 134 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U32BE); }
-#line 1552 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 26:
-#line 135 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U32LE); }
-#line 1558 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 27:
-#line 136 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U64BE); }
-#line 1564 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 28:
-#line 137 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_STD_U64LE); }
-#line 1570 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 29:
-#line 138 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_CHAR); }
-#line 1576 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 30:
-#line 139 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_SCHAR); }
-#line 1582 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 31:
-#line 140 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_UCHAR); }
-#line 1588 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 32:
-#line 141 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_SHORT); }
-#line 1594 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 33:
-#line 142 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_USHORT); }
-#line 1600 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 34:
-#line 143 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_INT); }
-#line 1606 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 35:
-#line 144 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_UINT); }
-#line 1612 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 36:
-#line 145 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_LONG); }
-#line 1618 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 37:
-#line 146 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_ULONG); }
-#line 1624 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 38:
-#line 147 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_LLONG); }
-#line 1630 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 39:
-#line 148 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_ULLONG); }
-#line 1636 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 40:
-#line 151 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_IEEE_F32BE); }
-#line 1642 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 41:
-#line 152 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_IEEE_F32LE); }
-#line 1648 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 42:
-#line 153 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_IEEE_F64BE); }
-#line 1654 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 43:
-#line 154 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_IEEE_F64LE); }
-#line 1660 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 44:
-#line 155 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_FLOAT); }
-#line 1666 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 45:
-#line 156 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_DOUBLE); }
-#line 1672 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 46:
-#line 157 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tcopy(H5T_NATIVE_LDOUBLE); }
-#line 1678 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 47:
-#line 161 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { csindex++; cmpd_stack[csindex].id = H5Tcreate(H5T_COMPOUND, 1); /*temporarily set size to 1*/ }
-#line 1684 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 48:
-#line 163 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = cmpd_stack[csindex].id; 
-                              cmpd_stack[csindex].id = 0;
-                              cmpd_stack[csindex].first_memb = 1; 
-                              csindex--;
-                            }
-#line 1694 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 51:
-#line 172 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { cmpd_stack[csindex].is_field = 1; /*notify lexer a compound member is parsed*/ }
-#line 1700 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 52:
-#line 174 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {   
-                            size_t origin_size, new_size;
-                            hid_t dtype_id = cmpd_stack[csindex].id;
-
-                            /*Adjust size and insert member, consider both member size and offset.*/
-                            if(cmpd_stack[csindex].first_memb) { /*reclaim the size 1 temporarily set*/
-                                new_size = H5Tget_size((yyvsp[-6].hid)) + (yyvsp[-1].ival);
-                                H5Tset_size(dtype_id, new_size);
-                                /*member name is saved in yylval.sval by lexer*/
-                                H5Tinsert(dtype_id, (yyvsp[-3].sval), (yyvsp[-1].ival), (yyvsp[-6].hid));
-
-                                cmpd_stack[csindex].first_memb = 0;
-                            } else {
-                                origin_size = H5Tget_size(dtype_id);
-                                
-                                if((yyvsp[-1].ival) == 0) {
-                                    new_size = origin_size + H5Tget_size((yyvsp[-6].hid));
-                                    H5Tset_size(dtype_id, new_size);
-                                    H5Tinsert(dtype_id, (yyvsp[-3].sval), origin_size, (yyvsp[-6].hid));
-                                } else {
-                                    new_size = (yyvsp[-1].ival) + H5Tget_size((yyvsp[-6].hid));
-                                    H5Tset_size(dtype_id, new_size);
-                                    H5Tinsert(dtype_id, (yyvsp[-3].sval), (yyvsp[-1].ival), (yyvsp[-6].hid));
-                                }
-                            }
-                            if((yyvsp[-3].sval)) {
-                                free((yyvsp[-3].sval));
-                                (yyvsp[-3].sval) = NULL;
-                            }
-                            cmpd_stack[csindex].is_field = 0;
-                            H5Tclose((yyvsp[-6].hid));
-                             
-                            new_size = H5Tget_size(dtype_id);
-                        }
-#line 1739 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 53:
-#line 210 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {
-                            (yyval.sval) = strdup(yylval.sval);
-                            free(yylval.sval);
-                            yylval.sval = NULL;
-                        }
-#line 1749 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 54:
-#line 217 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.ival) = 0; }
-#line 1755 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 55:
-#line 219 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.ival) = yylval.ival; }
-#line 1761 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 57:
-#line 223 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { asindex++; /*pushd onto the stack*/ }
-#line 1767 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 58:
-#line 225 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { 
-                          (yyval.hid) = H5Tarray_create2((yyvsp[-1].hid), arr_stack[asindex].ndims, arr_stack[asindex].dims);
-                          arr_stack[asindex].ndims = 0;
-                          asindex--;
-                          H5Tclose((yyvsp[-1].hid));
-                        }
-#line 1778 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 61:
-#line 235 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { arr_stack[asindex].is_dim = 1; /*notice lexer of dimension size*/ }
-#line 1784 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 62:
-#line 236 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { unsigned ndims = arr_stack[asindex].ndims;
-                                  arr_stack[asindex].dims[ndims] = (hsize_t)yylval.ival; 
-                                  arr_stack[asindex].ndims++;
-                                  arr_stack[asindex].is_dim = 0; 
-                                }
-#line 1794 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 65:
-#line 247 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = H5Tvlen_create((yyvsp[-1].hid)); H5Tclose((yyvsp[-1].hid)); }
-#line 1800 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 66:
-#line 252 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { is_opq_size = 1; }
-#line 1806 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 67:
-#line 253 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {   
-                                size_t size = (size_t)yylval.ival;
-                                (yyval.hid) = H5Tcreate(H5T_OPAQUE, size);
-                                is_opq_size = 0;    
-                            }
-#line 1816 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 68:
-#line 258 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { is_opq_tag = 1; }
-#line 1822 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 69:
-#line 259 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {  
-                                H5Tset_tag((yyvsp[-6].hid), yylval.sval);
-                                free(yylval.sval);
-                                yylval.sval = NULL;
-                                is_opq_tag = 0;
-                            }
-#line 1833 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 70:
-#line 265 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { (yyval.hid) = (yyvsp[-8].hid); }
-#line 1839 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 73:
-#line 273 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { is_str_size = 1; }
-#line 1845 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 74:
-#line 274 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {  
-                                if((yyvsp[-1].ival) == H5T_VARIABLE_TOKEN)
-                                    is_variable = 1;
-                                else 
-                                    str_size = yylval.ival;
-                                is_str_size = 0; 
-                            }
-#line 1857 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 75:
-#line 282 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {
-                                if((yyvsp[-1].ival) == H5T_STR_NULLTERM_TOKEN)
-                                    str_pad = H5T_STR_NULLTERM;
-                                else if((yyvsp[-1].ival) == H5T_STR_NULLPAD_TOKEN)
-                                    str_pad = H5T_STR_NULLPAD;
-                                else if((yyvsp[-1].ival) == H5T_STR_SPACEPAD_TOKEN)
-                                    str_pad = H5T_STR_SPACEPAD;
-                            }
-#line 1870 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 76:
-#line 291 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {  
-                                if((yyvsp[-1].ival) == H5T_CSET_ASCII_TOKEN)
-                                    str_cset = H5T_CSET_ASCII;
-                                else if((yyvsp[-1].ival) == H5T_CSET_UTF8_TOKEN)
-                                    str_cset = H5T_CSET_UTF8;
-                            }
-#line 1881 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 77:
-#line 298 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {
-                                if((yyvsp[-1].hid) == H5T_C_S1_TOKEN)
-                                    (yyval.hid) = H5Tcopy(H5T_C_S1);
-                                else if((yyvsp[-1].hid) == H5T_FORTRAN_S1_TOKEN)
-                                    (yyval.hid) = H5Tcopy(H5T_FORTRAN_S1);
-                            }
-#line 1892 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 78:
-#line 305 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {   
-                                hid_t str_id = (yyvsp[-1].hid);
-
-                                /*set string size*/
-                                if(is_variable) {
-                                    H5Tset_size(str_id, H5T_VARIABLE);
-                                    is_variable = 0;
-                                } else
-                                    H5Tset_size(str_id, str_size);
-                                
-                                /*set string padding and character set*/
-                                H5Tset_strpad(str_id, str_pad);
-                                H5Tset_cset(str_id, str_cset);
-
-                                (yyval.hid) = str_id; 
-                            }
-#line 1913 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 79:
-#line 322 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.ival) = H5T_VARIABLE_TOKEN;}
-#line 1919 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 81:
-#line 325 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.ival) = H5T_STR_NULLTERM_TOKEN;}
-#line 1925 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 82:
-#line 326 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.ival) = H5T_STR_NULLPAD_TOKEN;}
-#line 1931 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 83:
-#line 327 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.ival) = H5T_STR_SPACEPAD_TOKEN;}
-#line 1937 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 84:
-#line 329 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.ival) = H5T_CSET_ASCII_TOKEN;}
-#line 1943 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 85:
-#line 330 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.ival) = H5T_CSET_UTF8_TOKEN;}
-#line 1949 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 86:
-#line 332 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.hid) = H5T_C_S1_TOKEN;}
-#line 1955 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 87:
-#line 333 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {(yyval.hid) = H5T_FORTRAN_S1_TOKEN;}
-#line 1961 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 88:
-#line 337 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { is_enum = 1; enum_id = H5Tenum_create((yyvsp[-1].hid)); H5Tclose((yyvsp[-1].hid)); }
-#line 1967 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 89:
-#line 339 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    { is_enum = 0; /*reset*/ (yyval.hid) = enum_id; }
-#line 1973 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 92:
-#line 344 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {
-                                                is_enum_memb = 1; /*indicate member of enum*/
-#ifdef H5_HAVE_WIN32_API
-                                                enum_memb_symbol = _strdup(yylval.sval); 
-#else /* H5_HAVE_WIN32_API */
-                                                enum_memb_symbol = strdup(yylval.sval); 
-#endif  /* H5_HAVE_WIN32_API */
-                                                free(yylval.sval);
-                                                yylval.sval = NULL;
-                                            }
-#line 1988 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-  case 93:
-#line 355 "hl/src/H5LTparse.y" /* yacc.c:1646  */
-    {
-                                char char_val=(char)yylval.ival;
-                                short short_val=(short)yylval.ival;
-                                int int_val=(int)yylval.ival;
-                                long long_val=(long)yylval.ival;
-                                long long llong_val=(long long)yylval.ival;
-                                hid_t super = H5Tget_super(enum_id);
-                                hid_t native = H5Tget_native_type(super, H5T_DIR_ASCEND);
-                                H5T_order_t super_order = H5Tget_order(super);
-                                H5T_order_t native_order = H5Tget_order(native);
- 
-                                if(is_enum && is_enum_memb) { /*if it's an enum member*/
-                                    /*To handle machines of different endianness*/
-                                    if(H5Tequal(native, H5T_NATIVE_SCHAR) || H5Tequal(native, H5T_NATIVE_UCHAR)) {
-                                        if(super_order != native_order)
-                                            H5Tconvert(native, super, 1, &char_val, NULL, H5P_DEFAULT); 
-                                        H5Tenum_insert(enum_id, enum_memb_symbol, &char_val);
-                                    } else if(H5Tequal(native, H5T_NATIVE_SHORT) || H5Tequal(native, H5T_NATIVE_USHORT)) {
-                                        if(super_order != native_order)
-                                            H5Tconvert(native, super, 1, &short_val, NULL, H5P_DEFAULT); 
-                                        H5Tenum_insert(enum_id, enum_memb_symbol, &short_val);
-                                    } else if(H5Tequal(native, H5T_NATIVE_INT) || H5Tequal(native, H5T_NATIVE_UINT)) {
-                                        if(super_order != native_order)
-                                            H5Tconvert(native, super, 1, &int_val, NULL, H5P_DEFAULT); 
-                                        H5Tenum_insert(enum_id, enum_memb_symbol, &int_val);
-                                    } else if(H5Tequal(native, H5T_NATIVE_LONG) || H5Tequal(native, H5T_NATIVE_ULONG)) {
-                                        if(super_order != native_order)
-                                            H5Tconvert(native, super, 1, &long_val, NULL, H5P_DEFAULT); 
-                                        H5Tenum_insert(enum_id, enum_memb_symbol, &long_val);
-                                    } else if(H5Tequal(native, H5T_NATIVE_LLONG) || H5Tequal(native, H5T_NATIVE_ULLONG)) {
-                                        if(super_order != native_order)
-                                            H5Tconvert(native, super, 1, &llong_val, NULL, H5P_DEFAULT); 
-                                        H5Tenum_insert(enum_id, enum_memb_symbol, &llong_val);
-                                    }
-
-                                    is_enum_memb = 0; 
-                                    if(enum_memb_symbol) free(enum_memb_symbol);
-                                }
-
-                                H5Tclose(super);
-                                H5Tclose(native);
-                            }
-#line 2035 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-    break;
-
-
-#line 2039 "hl/src/H5LTparse.c" /* yacc.c:1646  */
-      default: break;
-    }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-  /* Now 'shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*--------------------------------------.
-| yyerrlab -- here on detecting error.  |
-`--------------------------------------*/
-yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-         error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* Return failure if at end of input.  */
-          if (yychar == YYEOF)
-            YYABORT;
-        }
-      else
-        {
-          yydestruct ("Error: discarding",
-                      yytoken, &yylval);
-          yychar = YYEMPTY;
-        }
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
-
-  /* Do not reclaim the symbols of the rule whose action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
-        {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-            {
-              yyn = yytable[yyn];
-              if (0 < yyn)
-                break;
-            }
-        }
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-        YYABORT;
-
-
-      yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-
-
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#if !defined yyoverflow || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
-    }
-  /* Do not reclaim the symbols of the rule whose action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
-  return yyresult;
-}
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the files COPYING and Copyright.html.  COPYING can be found at the root   *
+ * of the source code distribution tree; Copyright.html can be found at the  *
+ * root level of an installed copy of the electronic HDF5 document set and   *
+ * is linked from the top-level documents page.  It can also be found at     *
+ * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
+ * access to either file, you may request a copy from help@hdfgroup.org.     *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* This file was generated by Yacc with the command "yacc -pH5LTyy -o H5LTparse.c -d H5LTparse.y"
+ * on jam.  Do NOT modify it by hand.
+ */
+#ifndef lint
+static char const
+yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
+#endif
+#include <stdlib.h>
+#define YYBYACC 1
+#define YYMAJOR 1
+#define YYMINOR 9
+#define YYLEX yylex()
+#define YYEMPTY -1
+#define yyclearin (yychar=(YYEMPTY))
+#define yyerrok (yyerrflag=0)
+#define YYRECOVERING() (yyerrflag!=0)
+static int yygrowstack(void);
+#define yyparse H5LTyyparse
+#define yylex H5LTyylex
+#define yyerror H5LTyyerror
+#define yychar H5LTyychar
+#define yyval H5LTyyval
+#define yylval H5LTyylval
+#define yydebug H5LTyydebug
+#define yynerrs H5LTyynerrs
+#define yyerrflag H5LTyyerrflag
+#define yyss H5LTyyss
+#define yyssp H5LTyyssp
+#define yyvs H5LTyyvs
+#define yyvsp H5LTyyvsp
+#define yylhs H5LTyylhs
+#define yylen H5LTyylen
+#define yydefred H5LTyydefred
+#define yydgoto H5LTyydgoto
+#define yysindex H5LTyysindex
+#define yyrindex H5LTyyrindex
+#define yygindex H5LTyygindex
+#define yytable H5LTyytable
+#define yycheck H5LTyycheck
+#define yyname H5LTyyname
+#define yyrule H5LTyyrule
+#define yysslim H5LTyysslim
+#define yystacksize H5LTyystacksize
+#define YYPREFIX "H5LTyy"
+#line 17 "H5LTparse.y"
+#include<stdio.h>
+#include<string.h>
+#include<hdf5.h>
+
+extern int yylex(void);
+extern int yyerror(char *);
+
+#define STACK_SIZE      16
+
+/*structure for compound type information*/
+struct cmpd_info {
+    hid_t       id;             /*type ID*/
+    hbool_t     is_field;       /*flag to lexer for compound member*/
+    hbool_t     first_memb;     /*flag for first compound member*/
+};
+
+/*stack for nested compound type*/
+struct cmpd_info cmpd_stack[STACK_SIZE] = {
+    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
+    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
+    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
+    {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1} };
+
+int csindex = -1;                /*pointer to the top of compound stack*/
+
+/*structure for array type information*/
+struct arr_info {
+    hsize_t             dims[H5S_MAX_RANK];     /*size of each dimension, limited to 32 dimensions*/
+    unsigned            ndims;                  /*number of dimensions*/
+    hbool_t             is_dim;                 /*flag to lexer for dimension*/
+};
+/*stack for nested array type*/
+struct arr_info arr_stack[STACK_SIZE];
+int asindex = -1;               /*pointer to the top of array stack*/
+
+hbool_t     is_str_size = 0;        /*flag to lexer for string size*/
+hbool_t     is_str_pad = 0;         /*flag to lexer for string padding*/
+H5T_pad_t   str_pad;                /*variable for string padding*/
+H5T_cset_t  str_cset;               /*variable for string character set*/
+hbool_t     is_variable = 0;        /*variable for variable-length string*/
+size_t      str_size;               /*variable for string size*/
+
+hid_t       enum_id;                /*type ID*/
+hbool_t     is_enum = 0;            /*flag to lexer for enum type*/
+hbool_t     is_enum_memb = 0;       /*flag to lexer for enum member*/
+char*       enum_memb_symbol;       /*enum member symbol string*/
+
+hbool_t is_opq_size = 0;            /*flag to lexer for opaque type size*/
+hbool_t is_opq_tag = 0;             /*flag to lexer for opaque type tag*/
+
+#line 68 "H5LTparse.y"
+typedef union {
+    int   ival;         /*for integer token*/
+    char  *sval;        /*for name string*/
+} YYSTYPE;
+#line 99 "H5LTparse.c"
+#define YYERRCODE 256
+#define H5T_STD_I8BE_TOKEN 257
+#define H5T_STD_I8LE_TOKEN 258
+#define H5T_STD_I16BE_TOKEN 259
+#define H5T_STD_I16LE_TOKEN 260
+#define H5T_STD_I32BE_TOKEN 261
+#define H5T_STD_I32LE_TOKEN 262
+#define H5T_STD_I64BE_TOKEN 263
+#define H5T_STD_I64LE_TOKEN 264
+#define H5T_STD_U8BE_TOKEN 265
+#define H5T_STD_U8LE_TOKEN 266
+#define H5T_STD_U16BE_TOKEN 267
+#define H5T_STD_U16LE_TOKEN 268
+#define H5T_STD_U32BE_TOKEN 269
+#define H5T_STD_U32LE_TOKEN 270
+#define H5T_STD_U64BE_TOKEN 271
+#define H5T_STD_U64LE_TOKEN 272
+#define H5T_NATIVE_CHAR_TOKEN 273
+#define H5T_NATIVE_SCHAR_TOKEN 274
+#define H5T_NATIVE_UCHAR_TOKEN 275
+#define H5T_NATIVE_SHORT_TOKEN 276
+#define H5T_NATIVE_USHORT_TOKEN 277
+#define H5T_NATIVE_INT_TOKEN 278
+#define H5T_NATIVE_UINT_TOKEN 279
+#define H5T_NATIVE_LONG_TOKEN 280
+#define H5T_NATIVE_ULONG_TOKEN 281
+#define H5T_NATIVE_LLONG_TOKEN 282
+#define H5T_NATIVE_ULLONG_TOKEN 283
+#define H5T_IEEE_F32BE_TOKEN 284
+#define H5T_IEEE_F32LE_TOKEN 285
+#define H5T_IEEE_F64BE_TOKEN 286
+#define H5T_IEEE_F64LE_TOKEN 287
+#define H5T_NATIVE_FLOAT_TOKEN 288
+#define H5T_NATIVE_DOUBLE_TOKEN 289
+#define H5T_NATIVE_LDOUBLE_TOKEN 290
+#define H5T_STRING_TOKEN 291
+#define STRSIZE_TOKEN 292
+#define STRPAD_TOKEN 293
+#define CSET_TOKEN 294
+#define CTYPE_TOKEN 295
+#define H5T_VARIABLE_TOKEN 296
+#define H5T_STR_NULLTERM_TOKEN 297
+#define H5T_STR_NULLPAD_TOKEN 298
+#define H5T_STR_SPACEPAD_TOKEN 299
+#define H5T_CSET_ASCII_TOKEN 300
+#define H5T_CSET_UTF8_TOKEN 301
+#define H5T_C_S1_TOKEN 302
+#define H5T_FORTRAN_S1_TOKEN 303
+#define H5T_OPAQUE_TOKEN 304
+#define OPQ_SIZE_TOKEN 305
+#define OPQ_TAG_TOKEN 306
+#define H5T_COMPOUND_TOKEN 307
+#define H5T_ENUM_TOKEN 308
+#define H5T_ARRAY_TOKEN 309
+#define H5T_VLEN_TOKEN 310
+#define STRING 311
+#define NUMBER 312
+const short H5LTyylhs[] = {                                        -1,
+    0,    0,    1,    1,    1,    1,    2,    2,    2,    2,
+    2,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+    6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+    6,    6,    6,    6,    6,    6,    6,    6,    7,    7,
+    7,    7,    7,    7,    7,   11,    3,   12,   12,   14,
+   13,   15,   16,   16,   17,   18,    4,   19,   19,   22,
+   23,   20,   21,    5,   25,   26,   27,   29,   10,   24,
+   28,   31,   32,   34,   36,   38,    8,   30,   30,   33,
+   33,   33,   35,   35,   37,   37,   40,    9,   39,   39,
+   44,   41,   42,   43,
+};
+const short H5LTyylen[] = {                                         2,
+    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    0,    5,    0,    2,    0,
+    7,    1,    0,    2,    1,    0,    6,    0,    2,    0,
+    0,    5,    1,    4,    0,    0,    0,    0,   15,    1,
+    1,    0,    0,    0,    0,    0,   20,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    0,    7,    0,    2,
+    0,    6,    1,    1,
+};
+const short H5LTyydefred[] = {                                      0,
+   12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
+   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,
+   32,   33,   34,   35,   36,   37,   38,   39,   40,   41,
+   42,   43,   44,   45,    0,    0,   46,    0,   56,    0,
+    0,    2,    3,    4,    5,    6,    7,    8,    9,   10,
+   11,    0,    0,    0,    0,    0,    0,   72,   65,   48,
+    0,   58,    0,    0,    0,    0,   87,    0,   64,   78,
+   79,    0,   70,    0,   47,   50,   49,   89,   60,    0,
+   59,   73,   66,    0,    0,    0,   57,    0,    0,    0,
+   88,    0,   90,   63,   61,    0,   67,   52,    0,   93,
+    0,    0,   80,   81,   82,    0,    0,    0,   91,   62,
+   74,    0,    0,    0,    0,    0,   71,    0,   55,   54,
+   51,   94,    0,    0,    0,   92,   83,   84,    0,   68,
+   75,    0,    0,   69,    0,   85,   86,    0,   76,    0,
+   77,
+};
+const short H5LTyydgoto[] = {                                      41,
+   42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
+   54,   66,   77,   84,   99,  114,  120,   56,   68,   81,
+   95,   86,  102,   74,   65,   89,  107,  118,  132,   72,
+   64,   88,  106,  116,  129,  133,  138,  140,   85,   78,
+   93,  101,  123,  115,
+};
+const short H5LTyysindex[] = {                                   -255,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  -82,  -79,    0,  -78,    0,  -76,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, -208, -220,  -36, -201,  -34, -255,    0,    0,    0,
+   27,    0,  -35, -213, -221,  -37,    0,  -91,    0,    0,
+    0,   34,    0,   35,    0,    0,    0,    0,    0,  -30,
+    0,    0,    0,   62,  -33, -215,    0, -195, -206, -210,
+    0, -209,    0,    0,    0, -259,    0,    0,   69,    0,
+   70,   12,    0,    0,    0,   47,   73,   50,    0,    0,
+    0, -202, -200,   51, -199, -183,    0,   80,    0,    0,
+    0,    0,   56, -258,   57,    0,    0,    0,   58,    0,
+    0,   -7, -176,    0, -252,    0,    0,   61,    0,   -4,
+    0,
+};
+const short H5LTyyrindex[] = {                                    122,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   64,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,
+};
+const short H5LTyygindex[] = {                                      0,
+  -20,    0,    0,    0,    0,   71,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,
+};
+#define YYTABLESIZE 273
+const short H5LTyytable[] = {                                      79,
+   92,    1,    2,    3,    4,    5,    6,    7,    8,    9,
+   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
+   20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
+   30,   31,   32,   33,   34,   35,   63,  103,  104,  105,
+   52,  127,  128,   53,   55,   76,   57,   80,   36,  136,
+  137,   37,   38,   39,   40,    1,    2,    3,    4,    5,
+    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,
+   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,
+   26,   27,   70,   58,   59,   67,   60,   75,   62,   69,
+   73,   91,   82,   83,   87,   90,   94,   96,   71,   97,
+   98,  100,  108,  109,  110,  111,  112,  113,  117,  121,
+  124,  119,  122,  125,  126,  130,  131,  134,  135,  139,
+  141,    1,   53,    0,    0,   61,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    1,    2,    3,    4,    5,
+    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,
+   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,
+   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   36,    0,    0,   37,   38,   39,   40,    1,
+    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
+   12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
+   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,
+   32,   33,   34,   35,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   36,    0,    0,   37,
+   38,   39,   40,
+};
+const short H5LTyycheck[] = {                                      91,
+   34,  257,  258,  259,  260,  261,  262,  263,  264,  265,
+  266,  267,  268,  269,  270,  271,  272,  273,  274,  275,
+  276,  277,  278,  279,  280,  281,  282,  283,  284,  285,
+  286,  287,  288,  289,  290,  291,   57,  297,  298,  299,
+  123,  300,  301,  123,  123,   66,  123,   68,  304,  302,
+  303,  307,  308,  309,  310,  257,  258,  259,  260,  261,
+  262,  263,  264,  265,  266,  267,  268,  269,  270,  271,
+  272,  273,  274,  275,  276,  277,  278,  279,  280,  281,
+  282,  283,  296,  292,  305,   59,  123,  125,  123,  125,
+  312,  125,   59,   59,  125,   34,  312,  293,  312,  306,
+  311,  311,   34,   34,   93,   59,   34,   58,  311,   59,
+  294,  312,  312,   34,   59,   59,   59,  125,  295,   59,
+  125,    0,   59,   -1,   -1,   55,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  257,  258,  259,  260,  261,
+  262,  263,  264,  265,  266,  267,  268,  269,  270,  271,
+  272,  273,  274,  275,  276,  277,  278,  279,  280,  281,
+  282,  283,  284,  285,  286,  287,  288,  289,  290,  291,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  304,   -1,   -1,  307,  308,  309,  310,  257,
+  258,  259,  260,  261,  262,  263,  264,  265,  266,  267,
+  268,  269,  270,  271,  272,  273,  274,  275,  276,  277,
+  278,  279,  280,  281,  282,  283,  284,  285,  286,  287,
+  288,  289,  290,  291,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  304,   -1,   -1,  307,
+  308,  309,  310,
+};
+#define YYFINAL 41
+#ifndef YYDEBUG
+#define YYDEBUG 0
+#endif
+#define YYMAXTOKEN 312
+#if YYDEBUG
+const char * const H5LTyyname[] = {
+"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+"'\"'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"':'","';'",0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+"H5T_STD_I8BE_TOKEN","H5T_STD_I8LE_TOKEN","H5T_STD_I16BE_TOKEN",
+"H5T_STD_I16LE_TOKEN","H5T_STD_I32BE_TOKEN","H5T_STD_I32LE_TOKEN",
+"H5T_STD_I64BE_TOKEN","H5T_STD_I64LE_TOKEN","H5T_STD_U8BE_TOKEN",
+"H5T_STD_U8LE_TOKEN","H5T_STD_U16BE_TOKEN","H5T_STD_U16LE_TOKEN",
+"H5T_STD_U32BE_TOKEN","H5T_STD_U32LE_TOKEN","H5T_STD_U64BE_TOKEN",
+"H5T_STD_U64LE_TOKEN","H5T_NATIVE_CHAR_TOKEN","H5T_NATIVE_SCHAR_TOKEN",
+"H5T_NATIVE_UCHAR_TOKEN","H5T_NATIVE_SHORT_TOKEN","H5T_NATIVE_USHORT_TOKEN",
+"H5T_NATIVE_INT_TOKEN","H5T_NATIVE_UINT_TOKEN","H5T_NATIVE_LONG_TOKEN",
+"H5T_NATIVE_ULONG_TOKEN","H5T_NATIVE_LLONG_TOKEN","H5T_NATIVE_ULLONG_TOKEN",
+"H5T_IEEE_F32BE_TOKEN","H5T_IEEE_F32LE_TOKEN","H5T_IEEE_F64BE_TOKEN",
+"H5T_IEEE_F64LE_TOKEN","H5T_NATIVE_FLOAT_TOKEN","H5T_NATIVE_DOUBLE_TOKEN",
+"H5T_NATIVE_LDOUBLE_TOKEN","H5T_STRING_TOKEN","STRSIZE_TOKEN","STRPAD_TOKEN",
+"CSET_TOKEN","CTYPE_TOKEN","H5T_VARIABLE_TOKEN","H5T_STR_NULLTERM_TOKEN",
+"H5T_STR_NULLPAD_TOKEN","H5T_STR_SPACEPAD_TOKEN","H5T_CSET_ASCII_TOKEN",
+"H5T_CSET_UTF8_TOKEN","H5T_C_S1_TOKEN","H5T_FORTRAN_S1_TOKEN",
+"H5T_OPAQUE_TOKEN","OPQ_SIZE_TOKEN","OPQ_TAG_TOKEN","H5T_COMPOUND_TOKEN",
+"H5T_ENUM_TOKEN","H5T_ARRAY_TOKEN","H5T_VLEN_TOKEN","STRING","NUMBER",
+};
+const char * const H5LTyyrule[] = {
+"$accept : start",
+"start :",
+"start : ddl_type",
+"ddl_type : atomic_type",
+"ddl_type : compound_type",
+"ddl_type : array_type",
+"ddl_type : vlen_type",
+"atomic_type : integer_type",
+"atomic_type : fp_type",
+"atomic_type : string_type",
+"atomic_type : enum_type",
+"atomic_type : opaque_type",
+"integer_type : H5T_STD_I8BE_TOKEN",
+"integer_type : H5T_STD_I8LE_TOKEN",
+"integer_type : H5T_STD_I16BE_TOKEN",
+"integer_type : H5T_STD_I16LE_TOKEN",
+"integer_type : H5T_STD_I32BE_TOKEN",
+"integer_type : H5T_STD_I32LE_TOKEN",
+"integer_type : H5T_STD_I64BE_TOKEN",
+"integer_type : H5T_STD_I64LE_TOKEN",
+"integer_type : H5T_STD_U8BE_TOKEN",
+"integer_type : H5T_STD_U8LE_TOKEN",
+"integer_type : H5T_STD_U16BE_TOKEN",
+"integer_type : H5T_STD_U16LE_TOKEN",
+"integer_type : H5T_STD_U32BE_TOKEN",
+"integer_type : H5T_STD_U32LE_TOKEN",
+"integer_type : H5T_STD_U64BE_TOKEN",
+"integer_type : H5T_STD_U64LE_TOKEN",
+"integer_type : H5T_NATIVE_CHAR_TOKEN",
+"integer_type : H5T_NATIVE_SCHAR_TOKEN",
+"integer_type : H5T_NATIVE_UCHAR_TOKEN",
+"integer_type : H5T_NATIVE_SHORT_TOKEN",
+"integer_type : H5T_NATIVE_USHORT_TOKEN",
+"integer_type : H5T_NATIVE_INT_TOKEN",
+"integer_type : H5T_NATIVE_UINT_TOKEN",
+"integer_type : H5T_NATIVE_LONG_TOKEN",
+"integer_type : H5T_NATIVE_ULONG_TOKEN",
+"integer_type : H5T_NATIVE_LLONG_TOKEN",
+"integer_type : H5T_NATIVE_ULLONG_TOKEN",
+"fp_type : H5T_IEEE_F32BE_TOKEN",
+"fp_type : H5T_IEEE_F32LE_TOKEN",
+"fp_type : H5T_IEEE_F64BE_TOKEN",
+"fp_type : H5T_IEEE_F64LE_TOKEN",
+"fp_type : H5T_NATIVE_FLOAT_TOKEN",
+"fp_type : H5T_NATIVE_DOUBLE_TOKEN",
+"fp_type : H5T_NATIVE_LDOUBLE_TOKEN",
+"$$1 :",
+"compound_type : H5T_COMPOUND_TOKEN $$1 '{' memb_list '}'",
+"memb_list :",
+"memb_list : memb_list memb_def",
+"$$2 :",
+"memb_def : ddl_type $$2 '\"' field_name '\"' field_offset ';'",
+"field_name : STRING",
+"field_offset :",
+"field_offset : ':' offset",
+"offset : NUMBER",
+"$$3 :",
+"array_type : H5T_ARRAY_TOKEN $$3 '{' dim_list ddl_type '}'",
+"dim_list :",
+"dim_list : dim_list dim",
+"$$4 :",
+"$$5 :",
+"dim : '[' $$4 dimsize $$5 ']'",
+"dimsize : NUMBER",
+"vlen_type : H5T_VLEN_TOKEN '{' ddl_type '}'",
+"$$6 :",
+"$$7 :",
+"$$8 :",
+"$$9 :",
+"opaque_type : H5T_OPAQUE_TOKEN '{' OPQ_SIZE_TOKEN $$6 opaque_size ';' $$7 OPQ_TAG_TOKEN $$8 '\"' opaque_tag '\"' ';' $$9 '}'",
+"opaque_size : NUMBER",
+"opaque_tag : STRING",
+"$$10 :",
+"$$11 :",
+"$$12 :",
+"$$13 :",
+"$$14 :",
+"string_type : H5T_STRING_TOKEN '{' STRSIZE_TOKEN $$10 strsize ';' $$11 STRPAD_TOKEN strpad ';' $$12 CSET_TOKEN cset ';' $$13 CTYPE_TOKEN ctype ';' $$14 '}'",
+"strsize : H5T_VARIABLE_TOKEN",
+"strsize : NUMBER",
+"strpad : H5T_STR_NULLTERM_TOKEN",
+"strpad : H5T_STR_NULLPAD_TOKEN",
+"strpad : H5T_STR_SPACEPAD_TOKEN",
+"cset : H5T_CSET_ASCII_TOKEN",
+"cset : H5T_CSET_UTF8_TOKEN",
+"ctype : H5T_C_S1_TOKEN",
+"ctype : H5T_FORTRAN_S1_TOKEN",
+"$$15 :",
+"enum_type : H5T_ENUM_TOKEN '{' integer_type ';' $$15 enum_list '}'",
+"enum_list :",
+"enum_list : enum_list enum_def",
+"$$16 :",
+"enum_def : '\"' enum_symbol '\"' $$16 enum_val ';'",
+"enum_symbol : STRING",
+"enum_val : NUMBER",
+};
+#endif
+#if YYDEBUG
+#include <stdio.h>
+#endif
+#ifdef YYSTACKSIZE
+#undef YYMAXDEPTH
+#define YYMAXDEPTH YYSTACKSIZE
+#else
+#ifdef YYMAXDEPTH
+#define YYSTACKSIZE YYMAXDEPTH
+#else
+#define YYSTACKSIZE 10000
+#define YYMAXDEPTH 10000
+#endif
+#endif
+#define YYINITSTACKSIZE 200
+int yydebug;
+int yynerrs;
+int yyerrflag;
+int yychar;
+short *yyssp;
+YYSTYPE *yyvsp;
+YYSTYPE yyval;
+YYSTYPE yylval;
+short *yyss;
+short *yysslim;
+YYSTYPE *yyvs;
+int yystacksize;
+/* allocate initial stack or double stack size, up to YYMAXDEPTH */
+static int yygrowstack()
+{
+    int newsize, i;
+    short *newss;
+    YYSTYPE *newvs;
+
+    if ((newsize = yystacksize) == 0)
+        newsize = YYINITSTACKSIZE;
+    else if (newsize >= YYMAXDEPTH)
+        return -1;
+    else if ((newsize *= 2) > YYMAXDEPTH)
+        newsize = YYMAXDEPTH;
+    i = yyssp - yyss;
+    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
+      (short *)malloc(newsize * sizeof *newss);
+    if (newss == NULL)
+        return -1;
+    yyss = newss;
+    yyssp = newss + i;
+    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
+      (YYSTYPE *)malloc(newsize * sizeof *newvs);
+    if (newvs == NULL)
+        return -1;
+    yyvs = newvs;
+    yyvsp = newvs + i;
+    yystacksize = newsize;
+    yysslim = yyss + newsize - 1;
+    return 0;
+}
+
+#define YYABORT goto yyabort
+#define YYREJECT goto yyabort
+#define YYACCEPT goto yyaccept
+#define YYERROR goto yyerrlab
+
+#ifndef YYPARSE_PARAM
+#if defined(__cplusplus) || __STDC__
+#define YYPARSE_PARAM_ARG void
+#define YYPARSE_PARAM_DECL
+#else	/* ! ANSI-C/C++ */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif	/* ANSI-C/C++ */
+#else	/* YYPARSE_PARAM */
+#ifndef YYPARSE_PARAM_TYPE
+#define YYPARSE_PARAM_TYPE void *
+#endif
+#if defined(__cplusplus) || __STDC__
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else	/* ! ANSI-C/C++ */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
+#endif	/* ANSI-C/C++ */
+#endif	/* ! YYPARSE_PARAM */
+
+int
+yyparse (YYPARSE_PARAM_ARG)
+    YYPARSE_PARAM_DECL
+{
+    register int yym, yyn, yystate;
+#if YYDEBUG
+    register const char *yys;
+
+    if ((yys = getenv("YYDEBUG")))
+    {
+        yyn = *yys;
+        if (yyn >= '0' && yyn <= '9')
+            yydebug = yyn - '0';
+    }
+#endif
+
+    yynerrs = 0;
+    yyerrflag = 0;
+    yychar = (-1);
+
+    if (yyss == NULL && yygrowstack()) goto yyoverflow;
+    yyssp = yyss;
+    yyvsp = yyvs;
+    *yyssp = yystate = 0;
+
+yyloop:
+    if ((yyn = yydefred[yystate])) goto yyreduce;
+    if (yychar < 0)
+    {
+        if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, reading %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+    }
+    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: state %d, shifting to state %d\n",
+                    YYPREFIX, yystate, yytable[yyn]);
+#endif
+        if (yyssp >= yysslim && yygrowstack())
+        {
+            goto yyoverflow;
+        }
+        *++yyssp = yystate = yytable[yyn];
+        *++yyvsp = yylval;
+        yychar = (-1);
+        if (yyerrflag > 0)  --yyerrflag;
+        goto yyloop;
+    }
+    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+        yyn = yytable[yyn];
+        goto yyreduce;
+    }
+    if (yyerrflag) goto yyinrecovery;
+#if defined(lint) || defined(__GNUC__)
+    goto yynewerror;
+#endif
+yynewerror:
+    yyerror("syntax error");
+#if defined(lint) || defined(__GNUC__)
+    goto yyerrlab;
+#endif
+yyerrlab:
+    ++yynerrs;
+yyinrecovery:
+    if (yyerrflag < 3)
+    {
+        yyerrflag = 3;
+        for (;;)
+        {
+            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
+                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: state %d, error recovery shifting\
+ to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
+#endif
+                if (yyssp >= yysslim && yygrowstack())
+                {
+                    goto yyoverflow;
+                }
+                *++yyssp = yystate = yytable[yyn];
+                *++yyvsp = yylval;
+                goto yyloop;
+            }
+            else
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: error recovery discarding state %d\n",
+                            YYPREFIX, *yyssp);
+#endif
+                if (yyssp <= yyss) goto yyabort;
+                --yyssp;
+                --yyvsp;
+            }
+        }
+    }
+    else
+    {
+        if (yychar == 0) goto yyabort;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+        yychar = (-1);
+        goto yyloop;
+    }
+yyreduce:
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
+                YYPREFIX, yystate, yyn, yyrule[yyn]);
+#endif
+    yym = yylen[yyn];
+    yyval = yyvsp[1-yym];
+    switch (yyn)
+    {
+case 1:
+#line 100 "H5LTparse.y"
+{ memset(arr_stack, 0, STACK_SIZE*sizeof(struct arr_info)); /*initialize here?*/ }
+break;
+case 2:
+#line 101 "H5LTparse.y"
+{ return yyval.ival;}
+break;
+case 12:
+#line 115 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I8BE); }
+break;
+case 13:
+#line 116 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I8LE); }
+break;
+case 14:
+#line 117 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I16BE); }
+break;
+case 15:
+#line 118 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I16LE); }
+break;
+case 16:
+#line 119 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I32BE); }
+break;
+case 17:
+#line 120 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I32LE); }
+break;
+case 18:
+#line 121 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I64BE); }
+break;
+case 19:
+#line 122 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_I64LE); }
+break;
+case 20:
+#line 123 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U8BE); }
+break;
+case 21:
+#line 124 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U8LE); }
+break;
+case 22:
+#line 125 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U16BE); }
+break;
+case 23:
+#line 126 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U16LE); }
+break;
+case 24:
+#line 127 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U32BE); }
+break;
+case 25:
+#line 128 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U32LE); }
+break;
+case 26:
+#line 129 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U64BE); }
+break;
+case 27:
+#line 130 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_STD_U64LE); }
+break;
+case 28:
+#line 131 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_CHAR); }
+break;
+case 29:
+#line 132 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_SCHAR); }
+break;
+case 30:
+#line 133 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_UCHAR); }
+break;
+case 31:
+#line 134 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_SHORT); }
+break;
+case 32:
+#line 135 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_USHORT); }
+break;
+case 33:
+#line 136 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_INT); }
+break;
+case 34:
+#line 137 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_UINT); }
+break;
+case 35:
+#line 138 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_LONG); }
+break;
+case 36:
+#line 139 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_ULONG); }
+break;
+case 37:
+#line 140 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_LLONG); }
+break;
+case 38:
+#line 141 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_ULLONG); }
+break;
+case 39:
+#line 144 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_IEEE_F32BE); }
+break;
+case 40:
+#line 145 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_IEEE_F32LE); }
+break;
+case 41:
+#line 146 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_IEEE_F64BE); }
+break;
+case 42:
+#line 147 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_IEEE_F64LE); }
+break;
+case 43:
+#line 148 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_FLOAT); }
+break;
+case 44:
+#line 149 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_DOUBLE); }
+break;
+case 45:
+#line 150 "H5LTparse.y"
+{ yyval.ival = H5Tcopy(H5T_NATIVE_LDOUBLE); }
+break;
+case 46:
+#line 154 "H5LTparse.y"
+{ csindex++; cmpd_stack[csindex].id = H5Tcreate(H5T_COMPOUND, 1); /*temporarily set size to 1*/ }
+break;
+case 47:
+#line 156 "H5LTparse.y"
+{ yyval.ival = cmpd_stack[csindex].id;
+                              cmpd_stack[csindex].id = 0;
+                              cmpd_stack[csindex].first_memb = 1;
+                              csindex--;
+                            }
+break;
+case 50:
+#line 165 "H5LTparse.y"
+{ cmpd_stack[csindex].is_field = 1; /*notify lexer a compound member is parsed*/ }
+break;
+case 51:
+#line 167 "H5LTparse.y"
+{
+                            size_t origin_size, new_size;
+                            hid_t dtype_id = cmpd_stack[csindex].id;
+
+                            /*Adjust size and insert member, consider both member size and offset.*/
+                            if(cmpd_stack[csindex].first_memb) { /*reclaim the size 1 temporarily set*/
+                                new_size = H5Tget_size(yyvsp[-6].ival) + yyvsp[-1].ival;
+                                H5Tset_size(dtype_id, new_size);
+                                /*member name is saved in yylval.sval by lexer*/
+                                H5Tinsert(dtype_id, yyvsp[-3].sval, yyvsp[-1].ival, yyvsp[-6].ival);
+
+                                cmpd_stack[csindex].first_memb = 0;
+                            } else {
+                                origin_size = H5Tget_size(dtype_id);
+
+                                if(yyvsp[-1].ival == 0) {
+                                    new_size = origin_size + H5Tget_size(yyvsp[-6].ival);
+                                    H5Tset_size(dtype_id, new_size);
+                                    H5Tinsert(dtype_id, yyvsp[-3].sval, origin_size, yyvsp[-6].ival);
+                                } else {
+                                    new_size = yyvsp[-1].ival + H5Tget_size(yyvsp[-6].ival);
+                                    H5Tset_size(dtype_id, new_size);
+                                    H5Tinsert(dtype_id, yyvsp[-3].sval, yyvsp[-1].ival, yyvsp[-6].ival);
+                                }
+                            }
+
+                            cmpd_stack[csindex].is_field = 0;
+                            H5Tclose(yyvsp[-6].ival);
+
+                            new_size = H5Tget_size(dtype_id);
+                        }
+break;
+case 52:
+#line 200 "H5LTparse.y"
+{
+                            yyval.sval = yylval.sval;
+                        }
+break;
+case 53:
+#line 205 "H5LTparse.y"
+{ yyval.ival = 0; }
+break;
+case 54:
+#line 207 "H5LTparse.y"
+{ yyval.ival = yylval.ival; }
+break;
+case 56:
+#line 211 "H5LTparse.y"
+{ asindex++; /*pushd onto the stack*/ }
+break;
+case 57:
+#line 213 "H5LTparse.y"
+{
+                          yyval.ival = H5Tarray_create2(yyvsp[-1].ival, arr_stack[asindex].ndims, arr_stack[asindex].dims);
+                          arr_stack[asindex].ndims = 0;
+                          asindex--;
+                          H5Tclose(yyvsp[-1].ival);
+                        }
+break;
+case 60:
+#line 223 "H5LTparse.y"
+{ arr_stack[asindex].is_dim = 1; /*notice lexer of dimension size*/ }
+break;
+case 61:
+#line 224 "H5LTparse.y"
+{ unsigned ndims = arr_stack[asindex].ndims;
+                                  arr_stack[asindex].dims[ndims] = (hsize_t)yylval.ival;
+                                  arr_stack[asindex].ndims++;
+                                  arr_stack[asindex].is_dim = 0;
+                                }
+break;
+case 64:
+#line 235 "H5LTparse.y"
+{ yyval.ival = H5Tvlen_create(yyvsp[-1].ival); H5Tclose(yyvsp[-1].ival); }
+break;
+case 65:
+#line 240 "H5LTparse.y"
+{ is_opq_size = 1; }
+break;
+case 66:
+#line 241 "H5LTparse.y"
+{
+                                size_t size = (size_t)yylval.ival;
+                                yyval.ival = H5Tcreate(H5T_OPAQUE, size);
+                                is_opq_size = 0;
+                            }
+break;
+case 67:
+#line 246 "H5LTparse.y"
+{ is_opq_tag = 1; }
+break;
+case 68:
+#line 247 "H5LTparse.y"
+{
+                                H5Tset_tag(yyvsp[-6].ival, yylval.sval);
+                                is_opq_tag = 0;
+                            }
+break;
+case 69:
+#line 251 "H5LTparse.y"
+{ yyval.ival = yyvsp[-8].ival; }
+break;
+case 72:
+#line 259 "H5LTparse.y"
+{ is_str_size = 1; }
+break;
+case 73:
+#line 260 "H5LTparse.y"
+{
+                                if(yyvsp[-1].ival == H5T_VARIABLE_TOKEN)
+                                    is_variable = 1;
+                                else
+                                    str_size = yylval.ival;
+                                is_str_size = 0;
+                            }
+break;
+case 74:
+#line 268 "H5LTparse.y"
+{
+                                if(yyvsp[-1].ival == H5T_STR_NULLTERM_TOKEN)
+                                    str_pad = H5T_STR_NULLTERM;
+                                else if(yyvsp[-1].ival == H5T_STR_NULLPAD_TOKEN)
+                                    str_pad = H5T_STR_NULLPAD;
+                                else if(yyvsp[-1].ival == H5T_STR_SPACEPAD_TOKEN)
+                                    str_pad = H5T_STR_SPACEPAD;
+                            }
+break;
+case 75:
+#line 277 "H5LTparse.y"
+{
+                                if(yyvsp[-1].ival == H5T_CSET_ASCII_TOKEN)
+                                    str_cset = H5T_CSET_ASCII;
+                                else if(yyvsp[-1].ival == H5T_CSET_UTF8_TOKEN)
+                                    str_cset = H5T_CSET_UTF8;
+                            }
+break;
+case 76:
+#line 284 "H5LTparse.y"
+{
+                                if(yyvsp[-1].ival == H5T_C_S1_TOKEN)
+                                    yyval.ival = H5Tcopy(H5T_C_S1);
+                                else if(yyvsp[-1].ival == H5T_FORTRAN_S1_TOKEN)
+                                    yyval.ival = H5Tcopy(H5T_FORTRAN_S1);
+                            }
+break;
+case 77:
+#line 291 "H5LTparse.y"
+{
+                                hid_t str_id = yyvsp[-1].ival;
+
+                                /*set string size*/
+                                if(is_variable) {
+                                    H5Tset_size(str_id, H5T_VARIABLE);
+                                    is_variable = 0;
+                                } else
+                                    H5Tset_size(str_id, str_size);
+
+                                /*set string padding and character set*/
+                                H5Tset_strpad(str_id, str_pad);
+                                H5Tset_cset(str_id, str_cset);
+
+                                yyval.ival = str_id;
+                            }
+break;
+case 78:
+#line 308 "H5LTparse.y"
+{yyval.ival = H5T_VARIABLE_TOKEN;}
+break;
+case 80:
+#line 311 "H5LTparse.y"
+{yyval.ival = H5T_STR_NULLTERM_TOKEN;}
+break;
+case 81:
+#line 312 "H5LTparse.y"
+{yyval.ival = H5T_STR_NULLPAD_TOKEN;}
+break;
+case 82:
+#line 313 "H5LTparse.y"
+{yyval.ival = H5T_STR_SPACEPAD_TOKEN;}
+break;
+case 83:
+#line 315 "H5LTparse.y"
+{yyval.ival = H5T_CSET_ASCII_TOKEN;}
+break;
+case 84:
+#line 316 "H5LTparse.y"
+{yyval.ival = H5T_CSET_UTF8_TOKEN;}
+break;
+case 85:
+#line 318 "H5LTparse.y"
+{yyval.ival = H5T_C_S1_TOKEN;}
+break;
+case 86:
+#line 319 "H5LTparse.y"
+{yyval.ival = H5T_FORTRAN_S1_TOKEN;}
+break;
+case 87:
+#line 323 "H5LTparse.y"
+{ is_enum = 1; enum_id = H5Tenum_create(yyvsp[-1].ival); H5Tclose(yyvsp[-1].ival); }
+break;
+case 88:
+#line 325 "H5LTparse.y"
+{ is_enum = 0; /*reset*/ yyval.ival = enum_id; }
+break;
+case 91:
+#line 330 "H5LTparse.y"
+{
+                                                is_enum_memb = 1; /*indicate member of enum*/
+                                                enum_memb_symbol = strdup(yylval.sval);
+                                            }
+break;
+case 92:
+#line 335 "H5LTparse.y"
+{
+                                char char_val=(char)yylval.ival;
+                                short short_val=(short)yylval.ival;
+                                int int_val=(int)yylval.ival;
+                                long long_val=(long)yylval.ival;
+                                long long llong_val=(long long)yylval.ival;
+                                hid_t super = H5Tget_super(enum_id);
+                                hid_t native = H5Tget_native_type(super, H5T_DIR_ASCEND);
+                                H5T_order_t super_order = H5Tget_order(super);
+                                H5T_order_t native_order = H5Tget_order(native);
+
+                                if(is_enum && is_enum_memb) { /*if it's an enum member*/
+                                    /*To handle machines of different endianness*/
+                                    if(H5Tequal(native, H5T_NATIVE_SCHAR) || H5Tequal(native, H5T_NATIVE_UCHAR)) {
+                                        if(super_order != native_order)
+                                            H5Tconvert(native, super, 1, &char_val, NULL, H5P_DEFAULT);
+                                        H5Tenum_insert(enum_id, enum_memb_symbol, &char_val);
+                                    } else if(H5Tequal(native, H5T_NATIVE_SHORT) || H5Tequal(native, H5T_NATIVE_USHORT)) {
+                                        if(super_order != native_order)
+                                            H5Tconvert(native, super, 1, &short_val, NULL, H5P_DEFAULT);
+                                        H5Tenum_insert(enum_id, enum_memb_symbol, &short_val);
+                                    } else if(H5Tequal(native, H5T_NATIVE_INT) || H5Tequal(native, H5T_NATIVE_UINT)) {
+                                        if(super_order != native_order)
+                                            H5Tconvert(native, super, 1, &int_val, NULL, H5P_DEFAULT);
+                                        H5Tenum_insert(enum_id, enum_memb_symbol, &int_val);
+                                    } else if(H5Tequal(native, H5T_NATIVE_LONG) || H5Tequal(native, H5T_NATIVE_ULONG)) {
+                                        if(super_order != native_order)
+                                            H5Tconvert(native, super, 1, &long_val, NULL, H5P_DEFAULT);
+                                        H5Tenum_insert(enum_id, enum_memb_symbol, &long_val);
+                                    } else if(H5Tequal(native, H5T_NATIVE_LLONG) || H5Tequal(native, H5T_NATIVE_ULLONG)) {
+                                        if(super_order != native_order)
+                                            H5Tconvert(native, super, 1, &llong_val, NULL, H5P_DEFAULT);
+                                        H5Tenum_insert(enum_id, enum_memb_symbol, &llong_val);
+                                    }
+
+                                    is_enum_memb = 0;
+                                    if(enum_memb_symbol) free(enum_memb_symbol);
+                                }
+
+                                H5Tclose(super);
+                                H5Tclose(native);
+                            }
+break;
+#line 1076 "H5LTparse.c"
+    }
+    yyssp -= yym;
+    yystate = *yyssp;
+    yyvsp -= yym;
+    yym = yylhs[yyn];
+    if (yystate == 0 && yym == 0)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: after reduction, shifting from state 0 to\
+ state %d\n", YYPREFIX, YYFINAL);
+#endif
+        yystate = YYFINAL;
+        *++yyssp = YYFINAL;
+        *++yyvsp = yyval;
+        if (yychar < 0)
+        {
+            if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+            if (yydebug)
+            {
+                yys = 0;
+                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+                if (!yys) yys = "illegal-symbol";
+                printf("%sdebug: state %d, reading %d (%s)\n",
+                        YYPREFIX, YYFINAL, yychar, yys);
+            }
+#endif
+        }
+        if (yychar == 0) goto yyaccept;
+        goto yyloop;
+    }
+    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
+        yystate = yytable[yyn];
+    else
+        yystate = yydgoto[yym];
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: after reduction, shifting from state %d \
+to state %d\n", YYPREFIX, *yyssp, yystate);
+#endif
+    if (yyssp >= yysslim && yygrowstack())
+    {
+        goto yyoverflow;
+    }
+    *++yyssp = yystate;
+    *++yyvsp = yyval;
+    goto yyloop;
+yyoverflow:
+    yyerror("yacc stack overflow");
+yyabort:
+    return (1);
+yyaccept:
+    return (0);
+}
diff -ur hdf5-1.10.0-patch1/hl/src/H5LTparse.h hdf5/hl/src/H5LTparse.h
--- hdf5-1.10.0-patch1/hl/src/H5LTparse.h	2016-03-28 17:26:48.000000000 +0100
+++ hdf5/hl/src/H5LTparse.h	2021-01-25 11:09:43.000000000 +0000
@@ -1,129 +1,65 @@
-/* A Bison parser, made by GNU Bison 3.0.2.  */
-
-/* Bison interface for Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-#ifndef YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED
-# define YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int H5LTyydebug;
-#endif
-
-/* Token type.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    H5T_STD_I8BE_TOKEN = 258,
-    H5T_STD_I8LE_TOKEN = 259,
-    H5T_STD_I16BE_TOKEN = 260,
-    H5T_STD_I16LE_TOKEN = 261,
-    H5T_STD_I32BE_TOKEN = 262,
-    H5T_STD_I32LE_TOKEN = 263,
-    H5T_STD_I64BE_TOKEN = 264,
-    H5T_STD_I64LE_TOKEN = 265,
-    H5T_STD_U8BE_TOKEN = 266,
-    H5T_STD_U8LE_TOKEN = 267,
-    H5T_STD_U16BE_TOKEN = 268,
-    H5T_STD_U16LE_TOKEN = 269,
-    H5T_STD_U32BE_TOKEN = 270,
-    H5T_STD_U32LE_TOKEN = 271,
-    H5T_STD_U64BE_TOKEN = 272,
-    H5T_STD_U64LE_TOKEN = 273,
-    H5T_NATIVE_CHAR_TOKEN = 274,
-    H5T_NATIVE_SCHAR_TOKEN = 275,
-    H5T_NATIVE_UCHAR_TOKEN = 276,
-    H5T_NATIVE_SHORT_TOKEN = 277,
-    H5T_NATIVE_USHORT_TOKEN = 278,
-    H5T_NATIVE_INT_TOKEN = 279,
-    H5T_NATIVE_UINT_TOKEN = 280,
-    H5T_NATIVE_LONG_TOKEN = 281,
-    H5T_NATIVE_ULONG_TOKEN = 282,
-    H5T_NATIVE_LLONG_TOKEN = 283,
-    H5T_NATIVE_ULLONG_TOKEN = 284,
-    H5T_IEEE_F32BE_TOKEN = 285,
-    H5T_IEEE_F32LE_TOKEN = 286,
-    H5T_IEEE_F64BE_TOKEN = 287,
-    H5T_IEEE_F64LE_TOKEN = 288,
-    H5T_NATIVE_FLOAT_TOKEN = 289,
-    H5T_NATIVE_DOUBLE_TOKEN = 290,
-    H5T_NATIVE_LDOUBLE_TOKEN = 291,
-    H5T_STRING_TOKEN = 292,
-    STRSIZE_TOKEN = 293,
-    STRPAD_TOKEN = 294,
-    CSET_TOKEN = 295,
-    CTYPE_TOKEN = 296,
-    H5T_VARIABLE_TOKEN = 297,
-    H5T_STR_NULLTERM_TOKEN = 298,
-    H5T_STR_NULLPAD_TOKEN = 299,
-    H5T_STR_SPACEPAD_TOKEN = 300,
-    H5T_CSET_ASCII_TOKEN = 301,
-    H5T_CSET_UTF8_TOKEN = 302,
-    H5T_C_S1_TOKEN = 303,
-    H5T_FORTRAN_S1_TOKEN = 304,
-    H5T_OPAQUE_TOKEN = 305,
-    OPQ_SIZE_TOKEN = 306,
-    OPQ_TAG_TOKEN = 307,
-    H5T_COMPOUND_TOKEN = 308,
-    H5T_ENUM_TOKEN = 309,
-    H5T_ARRAY_TOKEN = 310,
-    H5T_VLEN_TOKEN = 311,
-    STRING = 312,
-    NUMBER = 313
-  };
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE YYSTYPE;
-union YYSTYPE
-{
-#line 74 "hl/src/H5LTparse.y" /* yacc.c:1909  */
-
-    int     ival;         /*for integer token*/
-    char    *sval;        /*for name string*/
-    hid_t   hid;          /*for hid_t token*/
-
-#line 119 "hl/src/H5LTparse.h" /* yacc.c:1909  */
-};
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-
-extern YYSTYPE H5LTyylval;
-
-int H5LTyyparse (void);
-
-#endif /* !YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED  */
+#ifndef YYERRCODE
+#define YYERRCODE 256
+#endif
+
+#define H5T_STD_I8BE_TOKEN 257
+#define H5T_STD_I8LE_TOKEN 258
+#define H5T_STD_I16BE_TOKEN 259
+#define H5T_STD_I16LE_TOKEN 260
+#define H5T_STD_I32BE_TOKEN 261
+#define H5T_STD_I32LE_TOKEN 262
+#define H5T_STD_I64BE_TOKEN 263
+#define H5T_STD_I64LE_TOKEN 264
+#define H5T_STD_U8BE_TOKEN 265
+#define H5T_STD_U8LE_TOKEN 266
+#define H5T_STD_U16BE_TOKEN 267
+#define H5T_STD_U16LE_TOKEN 268
+#define H5T_STD_U32BE_TOKEN 269
+#define H5T_STD_U32LE_TOKEN 270
+#define H5T_STD_U64BE_TOKEN 271
+#define H5T_STD_U64LE_TOKEN 272
+#define H5T_NATIVE_CHAR_TOKEN 273
+#define H5T_NATIVE_SCHAR_TOKEN 274
+#define H5T_NATIVE_UCHAR_TOKEN 275
+#define H5T_NATIVE_SHORT_TOKEN 276
+#define H5T_NATIVE_USHORT_TOKEN 277
+#define H5T_NATIVE_INT_TOKEN 278
+#define H5T_NATIVE_UINT_TOKEN 279
+#define H5T_NATIVE_LONG_TOKEN 280
+#define H5T_NATIVE_ULONG_TOKEN 281
+#define H5T_NATIVE_LLONG_TOKEN 282
+#define H5T_NATIVE_ULLONG_TOKEN 283
+#define H5T_IEEE_F32BE_TOKEN 284
+#define H5T_IEEE_F32LE_TOKEN 285
+#define H5T_IEEE_F64BE_TOKEN 286
+#define H5T_IEEE_F64LE_TOKEN 287
+#define H5T_NATIVE_FLOAT_TOKEN 288
+#define H5T_NATIVE_DOUBLE_TOKEN 289
+#define H5T_NATIVE_LDOUBLE_TOKEN 290
+#define H5T_STRING_TOKEN 291
+#define STRSIZE_TOKEN 292
+#define STRPAD_TOKEN 293
+#define CSET_TOKEN 294
+#define CTYPE_TOKEN 295
+#define H5T_VARIABLE_TOKEN 296
+#define H5T_STR_NULLTERM_TOKEN 297
+#define H5T_STR_NULLPAD_TOKEN 298
+#define H5T_STR_SPACEPAD_TOKEN 299
+#define H5T_CSET_ASCII_TOKEN 300
+#define H5T_CSET_UTF8_TOKEN 301
+#define H5T_C_S1_TOKEN 302
+#define H5T_FORTRAN_S1_TOKEN 303
+#define H5T_OPAQUE_TOKEN 304
+#define OPQ_SIZE_TOKEN 305
+#define OPQ_TAG_TOKEN 306
+#define H5T_COMPOUND_TOKEN 307
+#define H5T_ENUM_TOKEN 308
+#define H5T_ARRAY_TOKEN 309
+#define H5T_VLEN_TOKEN 310
+#define STRING 311
+#define NUMBER 312
+typedef union {
+    int   ival;         /*for integer token*/
+    char  *sval;        /*for name string*/
+} YYSTYPE;
+extern YYSTYPE H5LTyylval;
Only in hdf5-1.10.0-patch1/hl: test
Only in hdf5-1.10.0-patch1/hl: tools
Only in hdf5-1.10.0-patch1: java
Only in hdf5-1.10.0-patch1: m4
Only in hdf5-1.10.0-patch1: release_docs
diff -ur hdf5-1.10.0-patch1/src/H5B2cache.c hdf5/src/H5B2cache.c
--- hdf5-1.10.0-patch1/src/H5B2cache.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5B2cache.c	2021-01-25 11:09:43.000000000 +0000
@@ -695,6 +695,8 @@
     /* Allocate new internal node and reset cache info */
     if(NULL == (internal = H5FL_MALLOC(H5B2_internal_t)))
 	HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
+    internal->int_native = NULL;    //@AAPL <rdar://problem/36383106> CloudFuzz: out of bounds reads with ModelIO
+    internal->node_ptrs = NULL;     //@AAPL <rdar://problem/36383106> CloudFuzz: out of bounds reads with ModelIO
     HDmemset(&internal->cache_info, 0, sizeof(H5AC_info_t));
 
     /* Increment ref. count on B-tree header */
diff -ur hdf5-1.10.0-patch1/src/H5B2int.c hdf5/src/H5B2int.c
--- hdf5-1.10.0-patch1/src/H5B2int.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5B2int.c	2021-01-25 11:09:43.000000000 +0000
@@ -189,10 +189,10 @@
     H5B2_internal_t *internal, unsigned *internal_flags_ptr, unsigned idx)
 {
     const H5AC_class_t *child_class;    /* Pointer to child node's class info */
-    haddr_t left_addr, right_addr;      /* Addresses of left & right child nodes */
+    haddr_t left_addr = HADDR_UNDEF, right_addr = HADDR_UNDEF;      /* Addresses of left & right child nodes */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     void *left_child = NULL, *right_child = NULL;     /* Pointers to child nodes */
     const H5AC_class_t *grandchild_class; /* Pointer to grandchild node's class info */
-    haddr_t grandchild_addr;            /* Grandchild address */
+    haddr_t grandchild_addr = HADDR_UNDEF;            /* Grandchild address */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     void *grandchild = NULL;            /* Pointer to grandchild node */
     uint16_t *left_nrec, *right_nrec;   /* Pointers to child # of records */
     uint8_t *left_native, *right_native;/* Pointers to childs' native records */
@@ -200,7 +200,7 @@
     uint16_t mid_record;                /* Index of "middle" record in current node */
     uint16_t old_node_nrec;             /* Number of records in internal node split */
     unsigned left_child_flags = H5AC__NO_FLAGS_SET, right_child_flags = H5AC__NO_FLAGS_SET;     /* Flags for unprotecting child nodes */
-    unsigned u;                         /* Local index variable */
+    unsigned u = 0;                     /* Local index variable */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     herr_t ret_value = SUCCEED;         /* Return value */
 
     FUNC_ENTER_STATIC
@@ -543,7 +543,7 @@
     haddr_t left_addr, right_addr;      /* Addresses of left & right child nodes */
     void *left_child = NULL, *right_child = NULL;     /* Pointers to child nodes */
     const H5AC_class_t *grandchild_class; /* Pointer to grandchild node's class info */
-    haddr_t grandchild_addr;            /* Grandchild address */
+    haddr_t grandchild_addr = HADDR_UNDEF;        /* Grandchild address */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     void *grandchild = NULL;            /* Pointer to grandchild node */
     uint16_t *left_nrec, *right_nrec;   /* Pointers to child # of records */
     uint8_t *left_native, *right_native;    /* Pointers to childs' native records */
@@ -924,7 +924,7 @@
     void *left_child = NULL, *right_child = NULL;     /* Pointers to child nodes */
     void *middle_child = NULL;          /* Pointers to middle child node */
     const H5AC_class_t *grandchild_class; /* Pointer to grandchild node's class info */
-    haddr_t grandchild_addr;            /* Grandchild address */
+    haddr_t grandchild_addr = HADDR_UNDEF;            /* Grandchild address */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     void *grandchild = NULL;            /* Pointer to grandchild node */
     uint16_t *left_nrec, *right_nrec;   /* Pointers to child # of records */
     uint16_t *middle_nrec;              /* Pointers to middle child # of records */
@@ -1578,7 +1578,7 @@
     haddr_t left_addr, right_addr;      /* Addresses of left & right child nodes */
     void *left_child = NULL, *right_child = NULL;     /* Pointers to left & right child nodes */
     const H5AC_class_t *grandchild_class; /* Pointer to grandchild node's class info */
-    haddr_t grandchild_addr;            /* Grandchild address */
+    haddr_t grandchild_addr = HADDR_UNDEF;            /* Grandchild address */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     void *grandchild = NULL;            /* Pointer to grandchild node */
     uint16_t *left_nrec, *right_nrec;   /* Pointers to left & right child # of records */
     uint8_t *left_native, *right_native;    /* Pointers to left & right children's native records */
@@ -1819,7 +1819,7 @@
     void *left_child = NULL, *right_child = NULL;     /* Pointers to left & right child nodes */
     void *middle_child = NULL;          /* Pointer to middle child node */
     const H5AC_class_t *grandchild_class; /* Pointer to grandchild node's class info */
-    haddr_t grandchild_addr;            /* Grandchild address */
+    haddr_t grandchild_addr = HADDR_UNDEF;            /* Grandchild address */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     void *grandchild = NULL;            /* Pointer to grandchild node */
     uint16_t *left_nrec, *right_nrec;   /* Pointers to left & right child # of records */
     uint16_t *middle_nrec;              /* Pointer to middle child # of records */
diff -ur hdf5-1.10.0-patch1/src/H5C.c hdf5/src/H5C.c
--- hdf5-1.10.0-patch1/src/H5C.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5C.c	2021-01-25 11:09:43.000000000 +0000
@@ -3127,7 +3127,7 @@
 #ifdef H5_HAVE_PARALLEL
     hbool_t             coll_access = FALSE; /* whether access to the cache entry is done collectively */
 #endif /* H5_HAVE_PARALLEL */
-    hbool_t		write_permitted;
+    hbool_t		write_permitted = FALSE; // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     size_t		empty_space;
     void *		thing;
     H5C_cache_entry_t *	entry_ptr;
diff -ur hdf5-1.10.0-patch1/src/H5Dchunk.c hdf5/src/H5Dchunk.c
--- hdf5-1.10.0-patch1/src/H5Dchunk.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Dchunk.c	2021-01-25 11:09:43.000000000 +0000
@@ -2677,7 +2677,7 @@
 {
     H5D_rdcc_ent_t  *ent = NULL;        /* Cache entry */
     H5O_storage_chunk_t *sc = &(dset->shared->layout.storage.u.chunk);
-    unsigned idx;                       /* Index of chunk in cache, if present */
+    unsigned idx = 0;                   /* Index of chunk in cache, if present */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     hbool_t found = FALSE;              /* In cache? */
     herr_t ret_value = SUCCEED;	        /* Return value */
 
@@ -5398,6 +5398,7 @@
     hbool_t                 must_filter = FALSE;        /* Whether chunk must be filtered during copy */
     size_t                  nbytes;                     /* Size of chunk in file (in bytes) */
     H5Z_cb_t                cb_struct;                  /* Filter failure callback struct */
+    cb_struct.func = NULL;  // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     int                     ret_value = H5_ITER_CONT;   /* Return value */
 
     FUNC_ENTER_STATIC
diff -ur hdf5-1.10.0-patch1/src/H5Dvirtual.c hdf5/src/H5Dvirtual.c
--- hdf5-1.10.0-patch1/src/H5Dvirtual.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Dvirtual.c	2021-01-25 11:09:43.000000000 +0000
@@ -2087,7 +2087,7 @@
     hssize_t    select_nelmts;              /* Number of elements in selection */
     hsize_t     bounds_start[H5S_MAX_RANK]; /* Selection bounds start */
     hsize_t     bounds_end[H5S_MAX_RANK];   /* Selection bounds end */
-    int         rank;
+    int         rank = 0;  // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     hbool_t     bounds_init = FALSE;        /* Whether bounds_start, bounds_end, and rank are valid */
     size_t      i, j, k;                    /* Local index variables */
     herr_t      ret_value = SUCCEED;        /* Return value */
diff -ur hdf5-1.10.0-patch1/src/H5EA.c hdf5/src/H5EA.c
--- hdf5-1.10.0-patch1/src/H5EA.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5EA.c	2021-01-25 11:09:43.000000000 +0000
@@ -738,7 +738,7 @@
     /* Local variables */
     H5EA_hdr_t *hdr = ea->hdr;          /* Header for EA */
     void *thing = NULL;                 /* Pointer to the array metadata containing the array index we are interested in */
-    H5EA__unprotect_func_t thing_unprot_func;   /* Function pointer for unprotecting the array metadata */
+    H5EA__unprotect_func_t thing_unprot_func = NULL;  /* Function pointer for unprotecting the array metadata */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
 
 #ifdef QAK
 HDfprintf(stderr, "%s: Called\n", FUNC);
diff -ur hdf5-1.10.0-patch1/src/H5FDmulti.c hdf5/src/H5FDmulti.c
--- hdf5-1.10.0-patch1/src/H5FDmulti.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5FDmulti.c	2021-01-25 11:09:43.000000000 +0000
@@ -1799,7 +1799,7 @@
 {
     H5FD_multi_t	*file = (H5FD_multi_t*)_file;
     int			nerrors = 0;
-    H5FD_mem_t 		out_mt;
+    H5FD_mem_t 		out_mt = H5FD_MEM_DEFAULT; // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     static const char *func="H5FD_multi_unlock";  /* Function Name for error reporting */
 
     /* Clear the error stack */
diff -ur hdf5-1.10.0-patch1/src/H5FSsection.c hdf5/src/H5FSsection.c
--- hdf5-1.10.0-patch1/src/H5FSsection.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5FSsection.c	2021-01-25 11:09:43.000000000 +0000
@@ -1168,7 +1168,7 @@
     if(fspace->sinfo->merge_list) {
         do {
             H5SL_node_t *less_sect_node;    /* Skip list node for section less than new section */
-            H5SL_node_t *greater_sect_node; /* Skip list node for section greater than new section */
+            H5SL_node_t *greater_sect_node = NULL; /* Skip list node for section greater than new section */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
             H5FS_section_info_t *tmp_sect;  /* Temporary free space section */
             H5FS_section_class_t *tmp_sect_cls;     /* Temporary section's class */
             hbool_t greater_sect_node_valid = FALSE;    /* Indicate if 'greater than' section node is valid */
diff -ur hdf5-1.10.0-patch1/src/H5HFdbg.c hdf5/src/H5HFdbg.c
--- hdf5-1.10.0-patch1/src/H5HFdbg.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5HFdbg.c	2021-01-25 11:09:43.000000000 +0000
@@ -773,7 +773,7 @@
 {
     H5HF_hdr_t	*hdr = NULL;            /* Fractal heap header info */
     H5HF_indirect_t *iblock = NULL;     /* Fractal heap direct block info */
-    hbool_t did_protect;                /* Whether we protected the indirect block or not */
+    hbool_t did_protect = FALSE;        /* Whether we protected the indirect block or not */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
diff -ur hdf5-1.10.0-patch1/src/H5HFman.c hdf5/src/H5HFman.c
--- hdf5-1.10.0-patch1/src/H5HFman.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5HFman.c	2021-01-25 11:09:43.000000000 +0000
@@ -315,9 +315,9 @@
                                          * H5AC__NO_FLAGS_SET or 
                                          * H5AC__READ_ONLY_FLAG
                                          */
-    haddr_t dblock_addr;                /* Direct block address */
+    haddr_t dblock_addr = HADDR_UNDEF;  /* Direct block address */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     size_t dblock_size;                 /* Direct block size */
-    unsigned dblock_cache_flags;        /* Flags for unprotecting direct block */
+    unsigned dblock_cache_flags = 0;    /* Flags for unprotecting direct block */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     hsize_t obj_off;                    /* Object's offset in heap */
     size_t obj_len;                     /* Object's length in heap */
     size_t blk_off;                     /* Offset of object in block */
@@ -570,7 +570,7 @@
 {
     H5HF_free_section_t *sec_node = NULL; /* Pointer to free space section for block */
     H5HF_indirect_t *iblock = NULL;     /* Pointer to indirect block */
-    hbool_t did_protect;                /* Whether we protected the indirect block or not */
+    hbool_t did_protect = FALSE;        /* Whether we protected the indirect block or not */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     hsize_t obj_off;                    /* Object's offset in heap */
     size_t obj_len;                     /* Object's length in heap */
     size_t dblock_size;                 /* Direct block size */
diff -ur hdf5-1.10.0-patch1/src/H5HFsection.c hdf5/src/H5HFsection.c
--- hdf5-1.10.0-patch1/src/H5HFsection.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5HFsection.c	2021-01-25 11:09:43.000000000 +0000
@@ -2526,7 +2526,7 @@
 
             /* Add an indirect section for each indirect block in the row */
             for(v = 0; v < row_entries; v++) {
-                hbool_t did_protect;            /* Whether we protected the indirect block or not */
+                hbool_t did_protect = FALSE;            /* Whether we protected the indirect block or not */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
 
                 /* Try to get the child section's indirect block, if it's available */
                 if(sect->sect_info.state == H5FS_SECT_LIVE) {
diff -ur hdf5-1.10.0-patch1/src/H5HL.c hdf5/src/H5HL.c
--- hdf5-1.10.0-patch1/src/H5HL.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5HL.c	2021-01-25 11:09:43.000000000 +0000
@@ -997,7 +997,7 @@
 
     H5HL_cache_prfx_ud_t prfx_udata;    /* User data for protecting local heap prefix */
     H5HL_prfx_t *prfx = NULL;           /* Local heap prefix */
-    H5HL_t *heap;                       /* Heap data structure */
+    H5HL_t *heap = NULL;                /* Heap data structure */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
 
     /* check arguments */
     HDassert(f);
@@ -1048,7 +1048,7 @@
 
     H5HL_cache_prfx_ud_t prfx_udata;    /* User data for protecting local heap prefix */
     H5HL_prfx_t *prfx = NULL;           /* Local heap prefix */
-    H5HL_t *heap;                       /* Heap data structure */
+    H5HL_t *heap = NULL;                /* Heap data structure */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
 
     /* check arguments */
     HDassert(f);
diff -ur hdf5-1.10.0-patch1/src/H5I.c hdf5/src/H5I.c
--- hdf5-1.10.0-patch1/src/H5I.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5I.c	2021-01-25 11:09:43.000000000 +0000
@@ -220,7 +220,7 @@
 H5Iregister_type(size_t hash_size, unsigned reserved, H5I_free_t free_func)
 {
     H5I_class_t *cls = NULL;            /* New ID class */
-    H5I_type_t new_type;                /* New ID type value */
+    H5I_type_t new_type = H5I_UNINIT;   /* New ID type value */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     H5I_type_t ret_value = H5I_BADID;   /* Return value */
 
     FUNC_ENTER_API(H5I_BADID)
diff -ur hdf5-1.10.0-patch1/src/H5Oalloc.c hdf5/src/H5Oalloc.c
--- hdf5-1.10.0-patch1/src/H5Oalloc.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Oalloc.c	2021-01-25 11:09:43.000000000 +0000
@@ -1841,8 +1841,8 @@
                 /* Loop over messages again, looking for null message in same chunk */
                 for(v = 0, curr_msg2 = &oh->mesg[0]; v < oh->nmesgs; v++, curr_msg2++) {
                     if(u != v && H5O_NULL_ID == curr_msg2->type->id && curr_msg->chunkno == curr_msg2->chunkno) {
-                        ssize_t adj_raw;        /* Amount to adjust raw message pointer */
-                        size_t adj_raw_size;    /* Amount to adjust raw message size */
+                        ssize_t adj_raw = 0;        /* Amount to adjust raw message pointer */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
+                        size_t adj_raw_size = 0;    /* Amount to adjust raw message size */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
 
                         /* Check for second message after first message */
                         if((curr_msg->raw + curr_msg->raw_size) == (curr_msg2->raw - H5O_SIZEOF_MSGHDR_OH(oh))) {
diff -ur hdf5-1.10.0-patch1/src/H5Pdapl.c hdf5/src/H5Pdapl.c
--- hdf5-1.10.0-patch1/src/H5Pdapl.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Pdapl.c	2021-01-25 11:09:43.000000000 +0000
@@ -638,7 +638,7 @@
 static herr_t
 H5P__encode_chunk_cache_nslots(const void *value, void **_pp, size_t *size)
 {
-    uint64_t enc_value;     /* Property value to encode */
+    uint64_t enc_value = 0;     /* Property value to encode */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     uint8_t **pp = (uint8_t **)_pp;
     unsigned enc_size;      /* Size of encoded property */
 
@@ -748,7 +748,7 @@
 static herr_t
 H5P__encode_chunk_cache_nbytes(const void *value, void **_pp, size_t *size)
 {
-    uint64_t enc_value;     /* Property value to encode */
+    uint64_t enc_value = 0;     /* Property value to encode */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     uint8_t **pp = (uint8_t **)_pp;
     unsigned enc_size;      /* Size of encoded property */
 
diff -ur hdf5-1.10.0-patch1/src/H5Pdcpl.c hdf5/src/H5Pdcpl.c
--- hdf5-1.10.0-patch1/src/H5Pdcpl.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Pdcpl.c	2021-01-25 11:09:43.000000000 +0000
@@ -2134,7 +2134,7 @@
 H5Pset_virtual(hid_t dcpl_id, hid_t vspace_id, const char *src_file_name,
     const char *src_dset_name, hid_t src_space_id)
 {
-    H5P_genplist_t *plist;          /* Property list pointer */
+    H5P_genplist_t *plist = NULL;    /* Property list pointer */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     H5O_layout_t virtual_layout;    /* Layout information for setting virtual info */
     H5S_t *vspace;                  /* Virtual dataset space selection */
     H5S_t *src_space;               /* Source dataset space selection */
diff -ur hdf5-1.10.0-patch1/src/H5SM.c hdf5/src/H5SM.c
--- hdf5-1.10.0-patch1/src/H5SM.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5SM.c	2021-01-25 11:09:43.000000000 +0000
@@ -1553,7 +1553,7 @@
     ssize_t               index_num;
     void                 *mesg_buf = NULL;
     void                 *native_mesg = NULL;
-    unsigned              type_id;              /* Message type ID to operate on */
+    unsigned              type_id = 0;          /* Message type ID to operate on */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
     herr_t                ret_value = SUCCEED;
 
     FUNC_ENTER_NOAPI_TAG(dxpl_id, H5AC__SOHM_TAG, FAIL)
diff -ur hdf5-1.10.0-patch1/src/H5Shyper.c hdf5/src/H5Shyper.c
--- hdf5-1.10.0-patch1/src/H5Shyper.c	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Shyper.c	2021-01-25 11:09:43.000000000 +0000
@@ -759,7 +759,7 @@
     } /* end if */
     /* Must be an irregular hyperslab selection */
     else {
-        H5S_hyper_span_t *curr_span;    /* Current hyperslab span node */
+        H5S_hyper_span_t *curr_span = NULL;    /* Current hyperslab span node */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
         H5S_hyper_span_t **ispan;       /* Iterator's hyperslab span nodes */
         hsize_t *abs_arr;              /* Absolute hyperslab span position */
         int curr_dim;                   /* Temporary rank holder */
@@ -959,7 +959,7 @@
     } /* end if */
     /* Must be an irregular hyperslab selection */
     else {
-        H5S_hyper_span_t *curr_span;    /* Current hyperslab span node */
+        H5S_hyper_span_t *curr_span = NULL;    /* Current hyperslab span node */ // @AAPL rdar://58140915 (ModelKit has conditionally initialized variables)
         H5S_hyper_span_t **ispan;       /* Iterator's hyperslab span nodes */
         hsize_t *abs_arr;              /* Absolute hyperslab span position */
         int curr_dim;                   /* Temporary rank holder */
diff -ur hdf5-1.10.0-patch1/src/H5Tprivate.h hdf5/src/H5Tprivate.h
--- hdf5-1.10.0-patch1/src/H5Tprivate.h	2016-03-28 17:26:25.000000000 +0100
+++ hdf5/src/H5Tprivate.h	2021-01-25 11:09:43.000000000 +0000
@@ -137,6 +137,7 @@
 H5_DLL uint32_t H5T_hash(H5F_t * file, const H5T_t *dt);
 H5_DLL herr_t H5T_set_latest_version(H5T_t *dt);
 H5_DLL herr_t H5T_patch_file(H5T_t *dt, H5F_t *f);
+H5_DLL herr_t H5T_patch_vlen_file(H5T_t *dt, H5F_t *f);
 H5_DLL htri_t H5T_is_variable_str(const H5T_t *dt);
 
 /* Reference specific functions */
Only in hdf5/src: H5lib_settings.c
Only in hdf5/src: H5pubconf.h
Only in hdf5-1.10.0-patch1: test
Only in hdf5-1.10.0-patch1: testpar
Only in hdf5-1.10.0-patch1: tools
